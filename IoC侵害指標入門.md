# IoCï¼ˆIndicators of Compromiseï¼‰ä¾µå®³æŒ‡æ¨™å…¥é–€

## ç›®æ¬¡
1. [IoCã¨ã¯](#iocã¨ã¯)
2. [IoCã®é‡è¦æ€§](#iocã®é‡è¦æ€§)
3. [IoCã®ç¨®é¡ã¨åˆ†é¡](#iocã®ç¨®é¡ã¨åˆ†é¡)
4. [IoCã®åé›†æ–¹æ³•](#iocã®åé›†æ–¹æ³•)
5. [IoCã®åˆ†æã¨æ´»ç”¨](#iocã®åˆ†æã¨æ´»ç”¨)
6. [IoCã®å…±æœ‰ã¨æ¨™æº–åŒ–](#iocã®å…±æœ‰ã¨æ¨™æº–åŒ–)
7. [å®Ÿè·µçš„ãªæ¤œçŸ¥æ‰‹æ³•](#å®Ÿè·µçš„ãªæ¤œçŸ¥æ‰‹æ³•)
8. [ãƒ„ãƒ¼ãƒ«ã¨æŠ€è¡“](#ãƒ„ãƒ¼ãƒ«ã¨æŠ€è¡“)
9. [è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹](#è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹)
10. [ã‚ˆãã‚ã‚‹èª²é¡Œã¨å¯¾ç­–](#ã‚ˆãã‚ã‚‹èª²é¡Œã¨å¯¾ç­–)
11. [å®Ÿè£…ä¾‹ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](#å®Ÿè£…ä¾‹ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹)

## IoCã¨ã¯

**IoCï¼ˆIndicators of Compromiseï¼‰**ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒ**ã‚µã‚¤ãƒãƒ¼æ”»æ’ƒã‚’å—ã‘ãŸè¨¼æ‹ **ã‚„**æ”»æ’ƒã®ç—•è·¡**ã‚’ç¤ºã™ãƒ‡ã‚¸ã‚¿ãƒ«æƒ…å ±ã§ã™ã€‚

### åŸºæœ¬æ¦‚å¿µ

```
ğŸ” IoCã®åŸºæœ¬çš„ãªè€ƒãˆæ–¹

çŠ¯ç½ªç¾å ´ã®è¨¼æ‹ å“ã¨åŒã˜æ¦‚å¿µ:
ç‰©ç†çš„çŠ¯ç½ªç¾å ´    â†’    ã‚µã‚¤ãƒãƒ¼æ”»æ’ƒç¾å ´
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æŒ‡ç´‹             â†’    ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥å€¤
è¶³è·¡             â†’    ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é€šä¿¡å±¥æ­´
DNA              â†’    ãƒãƒ«ã‚¦ã‚§ã‚¢ã®ç‰¹å¾´çš„ã‚³ãƒ¼ãƒ‰
å‡¶å™¨             â†’    æ”»æ’ƒãƒ„ãƒ¼ãƒ«
ç›®æ’ƒè¨¼è¨€         â†’    ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«

ç›®çš„:
âœ… æ”»æ’ƒã®æ—©æœŸç™ºè¦‹
âœ… æ”»æ’ƒæ‰‹æ³•ã®ç‰¹å®š
âœ… å½±éŸ¿ç¯„å›²ã®æŠŠæ¡
âœ… å†ç™ºé˜²æ­¢ç­–ã®å®Ÿè£…
âœ… ä»–çµ„ç¹”ã¨ã®æƒ…å ±å…±æœ‰
```

### IoCã®ä¾‹

| IoCç¨®åˆ¥ | å…·ä½“ä¾‹ | èª¬æ˜ |
|---------|--------|------|
| **IPã‚¢ãƒ‰ãƒ¬ã‚¹** | 192.168.1.100 | æ”»æ’ƒå…ƒãƒ»C&Cã‚µãƒ¼ãƒãƒ¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ |
| **ãƒ‰ãƒ¡ã‚¤ãƒ³å** | malicious.example.com | æ‚ªæ„ã®ã‚ã‚‹ã‚µã‚¤ãƒˆã®ãƒ‰ãƒ¡ã‚¤ãƒ³ |
| **ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥** | d41d8cd98f00b204e9800998ecf8427e | ãƒãƒ«ã‚¦ã‚§ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€æ„è­˜åˆ¥å­ |
| **URL** | http://evil.com/malware.exe | ãƒãƒ«ã‚¦ã‚§ã‚¢é…å¸ƒã‚µã‚¤ãƒˆã®URL |
| **ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹** | attacker@evil.com | ãƒ•ã‚£ãƒƒã‚·ãƒ³ã‚°ãƒ¡ãƒ¼ãƒ«ã®é€ä¿¡å…ƒ |
| **ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã‚­ãƒ¼** | HKLM\Software\Malware | ãƒãƒ«ã‚¦ã‚§ã‚¢ãŒä½œæˆã™ã‚‹è¨­å®š |

## IoCã®é‡è¦æ€§

### ãªãœIoCãŒå¿…è¦ãªã®ã‹

```
ğŸ¯ IoCã®ä¾¡å€¤ã¨åŠ¹æœ

1. æ—©æœŸç™ºè¦‹ãƒ»å¯¾å¿œ
   å¾“æ¥: æ”»æ’ƒç™ºè¦šã¾ã§å¹³å‡200æ—¥
   IoCæ´»ç”¨: æ”»æ’ƒç™ºè¦šã¾ã§å¹³å‡æ•°æ™‚é–“ã€œæ•°æ—¥

2. æ”»æ’ƒã®å¯è¦–åŒ–
   - æ”»æ’ƒè€…ã®è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æŠŠæ¡
   - æ”»æ’ƒæ‰‹æ³•ã®è©³ç´°åˆ†æ
   - å½±éŸ¿ç¯„å›²ã®æ­£ç¢ºãªç‰¹å®š

3. äºˆé˜²çš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
   - æ—¢çŸ¥ã®è„…å¨ã®äº‹å‰ãƒ–ãƒ­ãƒƒã‚¯
   - é¡ä¼¼æ”»æ’ƒã®äºˆæ¸¬ãƒ»é˜²æ­¢
   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã®å„ªå…ˆé †ä½ä»˜ã‘

4. ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã®åŠ¹ç‡åŒ–
   - èª¿æŸ»æ™‚é–“ã®å¤§å¹…çŸ­ç¸®
   - æ ¹æœ¬åŸå› ã®è¿…é€Ÿãªç‰¹å®š
   - å¾©æ—§ä½œæ¥­ã®æœ€é©åŒ–
```

### æ”»æ’ƒã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã¨IoC

```
ğŸ”„ ã‚µã‚¤ãƒãƒ¼ã‚­ãƒ«ãƒã‚§ãƒ¼ãƒ³ã¨IoC

1. åµå¯Ÿï¼ˆReconnaissanceï¼‰
   IoCä¾‹: ç‰¹å®šIPã‹ã‚‰ã®å¤§é‡ã‚¹ã‚­ãƒ£ãƒ³ã€WHOISæ¤œç´¢å±¥æ­´

2. æ­¦å™¨åŒ–ï¼ˆWeaponizationï¼‰
   IoCä¾‹: ãƒãƒ«ã‚¦ã‚§ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ã€æ‚ªæ„ã®ã‚ã‚‹æ–‡æ›¸

3. é…é€ï¼ˆDeliveryï¼‰
   IoCä¾‹: ãƒ•ã‚£ãƒƒã‚·ãƒ³ã‚°ãƒ¡ãƒ¼ãƒ«é€ä¿¡å…ƒã€ãƒãƒ«ã‚¦ã‚§ã‚¢é…å¸ƒURL

4. ä¾µå…¥ï¼ˆExploitationï¼‰
   IoCä¾‹: è„†å¼±æ€§æ”»æ’ƒã‚³ãƒ¼ãƒ‰ã€ç•°å¸¸ãªãƒ—ãƒ­ã‚»ã‚¹å®Ÿè¡Œ

5. ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆInstallationï¼‰
   IoCä¾‹: ä¸å¯©ãªãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆã€ãƒ¬ã‚¸ã‚¹ãƒˆãƒªå¤‰æ›´

6. C&Cé€šä¿¡ï¼ˆCommand and Controlï¼‰
   IoCä¾‹: C&Cã‚µãƒ¼ãƒãƒ¼IPã€é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã€æš—å·åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«

7. ç›®çš„å®Ÿè¡Œï¼ˆActions on Objectivesï¼‰
   IoCä¾‹: ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã€å†…éƒ¨ç§»å‹•ã®ç—•è·¡
```

## IoCã®ç¨®é¡ã¨åˆ†é¡

### æŠ€è¡“çš„åˆ†é¡

#### 1. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç³»IoC

```
ğŸŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é–¢é€£ã®ä¾µå®³æŒ‡æ¨™

IPã‚¢ãƒ‰ãƒ¬ã‚¹:
- C&Cã‚µãƒ¼ãƒãƒ¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹
- æ”»æ’ƒå…ƒã®IPã‚¢ãƒ‰ãƒ¬ã‚¹
- ãƒ‡ãƒ¼ã‚¿çªƒå–å…ˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹
ä¾‹: 203.0.113.100, 192.168.1.50

ãƒ‰ãƒ¡ã‚¤ãƒ³å:
- æ‚ªæ„ã®ã‚ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³
- C&Cã‚µãƒ¼ãƒãƒ¼ã®ãƒ‰ãƒ¡ã‚¤ãƒ³
- ãƒ•ã‚£ãƒƒã‚·ãƒ³ã‚°ã‚µã‚¤ãƒˆã®ãƒ‰ãƒ¡ã‚¤ãƒ³
ä¾‹: evil-bank.com, malware-c2.net

URL:
- ãƒãƒ«ã‚¦ã‚§ã‚¢é…å¸ƒURL
- ãƒ•ã‚£ãƒƒã‚·ãƒ³ã‚°ãƒšãƒ¼ã‚¸URL
- ãƒ‡ãƒ¼ã‚¿é€ä¿¡å…ˆURL
ä¾‹: http://malicious.com/payload.exe

ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³:
- ç‰¹å¾´çš„ãªé€šä¿¡é–“éš”
- ç•°å¸¸ãªãƒ‡ãƒ¼ã‚¿é‡
- æš—å·åŒ–ã•ã‚ŒãŸC&Cé€šä¿¡
ä¾‹: 60ç§’é–“éš”ã®ãƒ“ãƒ¼ã‚³ãƒ³é€šä¿¡
```

#### 2. ãƒ•ã‚¡ã‚¤ãƒ«ç³»IoC

```
ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«é–¢é€£ã®ä¾µå®³æŒ‡æ¨™

ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥:
- MD5: 32æ–‡å­—ã®16é€²æ•°
- SHA-1: 40æ–‡å­—ã®16é€²æ•°
- SHA-256: 64æ–‡å­—ã®16é€²æ•°ï¼ˆæ¨å¥¨ï¼‰
ä¾‹: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

ãƒ•ã‚¡ã‚¤ãƒ«å:
- ãƒãƒ«ã‚¦ã‚§ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«å
- å½è£…ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«å
- ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«å
ä¾‹: invoice.pdf.exe, system32.dll, ~tmp1234.exe

ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹:
- ãƒãƒ«ã‚¦ã‚§ã‚¢ã®é…ç½®å ´æ‰€
- ä¸å¯©ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- éš ã—ãƒ•ã‚©ãƒ«ãƒ€
ä¾‹: C:\Windows\Temp\malware.exe, %APPDATA%\suspicious\

ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º:
- ç‰¹å®šãƒãƒ«ã‚¦ã‚§ã‚¢ã®å›ºæœ‰ã‚µã‚¤ã‚º
- ç•°å¸¸ã«å¤§ãã„/å°ã•ã„ãƒ•ã‚¡ã‚¤ãƒ«
ä¾‹: 1,234,567 bytes
```

#### 3. ã‚·ã‚¹ãƒ†ãƒ ç³»IoC

```
âš™ï¸ ã‚·ã‚¹ãƒ†ãƒ é–¢é€£ã®ä¾µå®³æŒ‡æ¨™

ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã‚­ãƒ¼:
- è‡ªå‹•å®Ÿè¡Œè¨­å®š
- ãƒãƒ«ã‚¦ã‚§ã‚¢è¨­å®šæƒ…å ±
- æ”»æ’ƒè€…ãŒæ®‹ã—ãŸç—•è·¡
ä¾‹: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\Malware

ãƒ—ãƒ­ã‚»ã‚¹æƒ…å ±:
- ä¸å¯©ãªãƒ—ãƒ­ã‚»ã‚¹å
- ç•°å¸¸ãªãƒ—ãƒ­ã‚»ã‚¹å®Ÿè¡Œ
- è¦ªå­ãƒ—ãƒ­ã‚»ã‚¹é–¢ä¿‚
ä¾‹: svchost.exeï¼ˆæ­£è¦ã®å ´æ‰€ä»¥å¤–ã‹ã‚‰å®Ÿè¡Œï¼‰

ã‚µãƒ¼ãƒ“ã‚¹å:
- ä¸å¯©ãªWindowsã‚µãƒ¼ãƒ“ã‚¹
- å½è£…ã•ã‚ŒãŸã‚µãƒ¼ãƒ“ã‚¹å
ä¾‹: "Windows Security Update Service"ï¼ˆå½è£…ï¼‰

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ:
- ä¸å¯©ãªã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ
- æ¨©é™æ˜‡æ ¼ã®ç—•è·¡
ä¾‹: admin123, temp_user
```

### ä¿¡é ¼åº¦ã«ã‚ˆã‚‹åˆ†é¡

```
ğŸ¯ IoCã®ä¿¡é ¼åº¦ãƒ¬ãƒ™ãƒ«

High Confidenceï¼ˆé«˜ä¿¡é ¼åº¦ï¼‰:
- ç¢ºå®Ÿã«æ‚ªæ„ãŒã‚ã‚‹ã¨åˆ¤æ–­ã§ãã‚‹
- èª¤æ¤œçŸ¥ã®å¯èƒ½æ€§ãŒæ¥µã‚ã¦ä½ã„
- å³åº§ã«ãƒ–ãƒ­ãƒƒã‚¯å¯¾è±¡
ä¾‹: æ—¢çŸ¥ã®ãƒãƒ«ã‚¦ã‚§ã‚¢ãƒãƒƒã‚·ãƒ¥å€¤

Medium Confidenceï¼ˆä¸­ä¿¡é ¼åº¦ï¼‰:
- æ‚ªæ„ãŒã‚ã‚‹å¯èƒ½æ€§ãŒé«˜ã„
- è¿½åŠ èª¿æŸ»ãŒå¿…è¦
- ç›£è¦–å¼·åŒ–å¯¾è±¡
ä¾‹: ä¸å¯©ãªé€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³

Low Confidenceï¼ˆä½ä¿¡é ¼åº¦ï¼‰:
- æ‚ªæ„ãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
- æ­£å¸¸ãªæ´»å‹•ã®å¯èƒ½æ€§ã‚‚ã‚ã‚‹
- æƒ…å ±åé›†ãƒ»åˆ†æå¯¾è±¡
ä¾‹: æ–°ã—ãç™»éŒ²ã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³
```

## IoCã®åé›†æ–¹æ³•

### 1. å†…éƒ¨ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®åé›†

```
ğŸ¢ çµ„ç¹”å†…ã§ã®IoCåé›†

ãƒ­ã‚°åˆ†æ:
â–¡ ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ­ã‚°
â–¡ ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚°
â–¡ DNSã‚¯ã‚¨ãƒªãƒ­ã‚°
â–¡ Webã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚°
â–¡ ãƒ¡ãƒ¼ãƒ«ã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚°
â–¡ Active Directoryãƒ­ã‚°

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ„ãƒ¼ãƒ«:
â–¡ ã‚¢ãƒ³ãƒã‚¦ã‚¤ãƒ«ã‚¹æ¤œçŸ¥çµæœ
â–¡ IDS/IPS ã‚¢ãƒ©ãƒ¼ãƒˆ
â–¡ SIEM ã‚·ã‚¹ãƒ†ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ
â–¡ EDRï¼ˆEndpoint Detection and Responseï¼‰
â–¡ ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹åˆ†æçµæœ

ãƒ•ã‚©ãƒ¬ãƒ³ã‚¸ãƒƒã‚¯èª¿æŸ»:
â–¡ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œæ™‚ã®ç™ºè¦‹äº‹é …
â–¡ ãƒãƒ«ã‚¦ã‚§ã‚¢è§£æçµæœ
â–¡ ãƒ¡ãƒ¢ãƒªãƒ•ã‚©ãƒ¬ãƒ³ã‚¸ãƒƒã‚¯
â–¡ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ•ã‚©ãƒ¬ãƒ³ã‚¸ãƒƒã‚¯
```

#### ãƒ­ã‚°åˆ†æã®å®Ÿä¾‹

```bash
# Webã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚°ã‹ã‚‰ã®ä¸å¯©ãªã‚¢ã‚¯ã‚»ã‚¹æ¤œå‡º
# /var/log/apache2/access.log

# SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒã®ç—•è·¡
grep -E "(union|select|insert|drop|delete)" /var/log/apache2/access.log

# ç•°å¸¸ã«å¤šã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ¤œå‡º
awk '{print $1}' /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -10

# ä¸å¯©ãªUser-Agentã®æ¤œå‡º
grep -E "(bot|crawler|scanner)" /var/log/apache2/access.log

# ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ­ã‚°ã‹ã‚‰ã®ä¸å¯©ãªé€šä¿¡æ¤œå‡º
# çŸ­æ™‚é–“ã§ã®å¤§é‡æ¥ç¶šè©¦è¡Œ
awk '$6=="TCP" && $7=="SYN" {count[$3]++} END {for(ip in count) if(count[ip]>100) print ip, count[ip]}' /var/log/firewall.log
```

### 2. å¤–éƒ¨ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®åé›†

```
ğŸŒ å¤–éƒ¨è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ã‚½ãƒ¼ã‚¹

å•†ç”¨ãƒ•ã‚£ãƒ¼ãƒ‰:
- Recorded Future
- ThreatConnect
- Anomali
- IBM X-Force
- FireEye Intelligence

ç„¡æ–™ãƒ»ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹:
- MISPï¼ˆMalware Information Sharing Platformï¼‰
- OpenIOC
- YARA Rules
- Threat Exchangeï¼ˆFacebookï¼‰
- OTXï¼ˆAlienVault Open Threat Exchangeï¼‰

æ”¿åºœãƒ»æ¥­ç•Œå›£ä½“:
- JPCERT/CC
- IPAï¼ˆæƒ…å ±å‡¦ç†æ¨é€²æ©Ÿæ§‹ï¼‰
- US-CERT
- æ¥­ç•ŒISACï¼ˆInformation Sharing and Analysis Centerï¼‰

ç ”ç©¶æ©Ÿé–¢ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ãƒ³ãƒ€ãƒ¼:
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ãƒ³ãƒ€ãƒ¼ã®ãƒ–ãƒ­ã‚°
- å­¦è¡“ç ”ç©¶è«–æ–‡
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚«ãƒ³ãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹è³‡æ–™
```

### 3. è‡ªå‹•åé›†ã‚·ã‚¹ãƒ†ãƒ 

```python
# IoCè‡ªå‹•åé›†ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¾‹
import requests
import json
import hashlib
import re
from datetime import datetime

class IoCCollector:
    def __init__(self):
        self.iocs = {
            'ip_addresses': [],
            'domains': [],
            'file_hashes': [],
            'urls': []
        }
    
    def collect_from_logs(self, log_file):
        """ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰IoCã‚’æŠ½å‡º"""
        with open(log_file, 'r') as f:
            content = f.read()
            
        # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®æŠ½å‡º
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        ips = re.findall(ip_pattern, content)
        self.iocs['ip_addresses'].extend(ips)
        
        # ãƒ‰ãƒ¡ã‚¤ãƒ³ã®æŠ½å‡º
        domain_pattern = r'\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\b'
        domains = re.findall(domain_pattern, content)
        self.iocs['domains'].extend([d[0] for d in domains])
    
    def collect_from_threat_feed(self, feed_url, api_key):
        """å¤–éƒ¨è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰ã‹ã‚‰IoCã‚’åé›†"""
        headers = {'Authorization': f'Bearer {api_key}'}
        response = requests.get(feed_url, headers=headers)
        
        if response.status_code == 200:
            threat_data = response.json()
            for indicator in threat_data.get('indicators', []):
                ioc_type = indicator.get('type')
                ioc_value = indicator.get('value')
                
                if ioc_type == 'ip':
                    self.iocs['ip_addresses'].append(ioc_value)
                elif ioc_type == 'domain':
                    self.iocs['domains'].append(ioc_value)
                elif ioc_type == 'hash':
                    self.iocs['file_hashes'].append(ioc_value)
    
    def analyze_file_hash(self, file_path):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—"""
        sha256_hash = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        
        hash_value = sha256_hash.hexdigest()
        self.iocs['file_hashes'].append(hash_value)
        return hash_value
    
    def export_iocs(self, output_file):
        """åé›†ã—ãŸIoCã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›"""
        ioc_data = {
            'timestamp': datetime.now().isoformat(),
            'total_indicators': sum(len(v) for v in self.iocs.values()),
            'indicators': self.iocs
        }
        
        with open(output_file, 'w') as f:
            json.dump(ioc_data, f, indent=2)

# ä½¿ç”¨ä¾‹
collector = IoCCollector()
collector.collect_from_logs('/var/log/security.log')
collector.collect_from_threat_feed('https://api.threatfeed.com/v1/indicators', 'your-api-key')
collector.export_iocs('collected_iocs.json')
```

## IoCã®åˆ†æã¨æ´»ç”¨

### 1. IoCåˆ†æã®ãƒ—ãƒ­ã‚»ã‚¹

```
ğŸ” IoCåˆ†æã®æ¨™æº–çš„ãªæµã‚Œ

1. ãƒ‡ãƒ¼ã‚¿åé›†ãƒ»æ­£è¦åŒ–
   â–¡ è¤‡æ•°ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®IoCåé›†
   â–¡ ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®çµ±ä¸€
   â–¡ é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã®é™¤å»
   â–¡ å“è³ªãƒã‚§ãƒƒã‚¯

2. ä¿¡é ¼åº¦è©•ä¾¡
   â–¡ ã‚½ãƒ¼ã‚¹ã®ä¿¡é ¼æ€§ç¢ºèª
   â–¡ éå»ã®æ¤œçŸ¥å®Ÿç¸¾è©•ä¾¡
   â–¡ èª¤æ¤œçŸ¥ç‡ã®åˆ†æ
   â–¡ æ–‡è„ˆæƒ…å ±ã®è€ƒæ…®

3. é–¢é€£æ€§åˆ†æ
   â–¡ IoCé–“ã®é–¢é€£æ€§ç™ºè¦‹
   â–¡ æ”»æ’ƒã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã®ç‰¹å®š
   â–¡ æ”»æ’ƒè€…ã‚°ãƒ«ãƒ¼ãƒ—ã®è­˜åˆ¥
   â–¡ TTPï¼ˆæˆ¦è¡“ãƒ»æŠ€è¡“ãƒ»æ‰‹é †ï¼‰ã®åˆ†æ

4. è„…å¨ãƒ¬ãƒ™ãƒ«åˆ¤å®š
   â–¡ çµ„ç¹”ã¸ã®å½±éŸ¿åº¦è©•ä¾¡
   â–¡ ç·Šæ€¥åº¦ã®åˆ¤å®š
   â–¡ å¯¾å¿œå„ªå…ˆåº¦ã®æ±ºå®š
   â–¡ ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ã®ç®—å®š

5. å¯¾å¿œç­–ã®æ±ºå®š
   â–¡ ãƒ–ãƒ­ãƒƒã‚¯ãƒªã‚¹ãƒˆè¿½åŠ 
   â–¡ ç›£è¦–å¼·åŒ–è¨­å®š
   â–¡ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œèµ·å‹•
   â–¡ äºˆé˜²ç­–ã®å®Ÿè£…
```

### 2. IoCåˆ†æãƒ„ãƒ¼ãƒ«ã®æ´»ç”¨

```python
# IoCåˆ†æã‚¹ã‚¯ãƒªãƒ—ãƒˆä¾‹
import ipaddress
import dns.resolver
import whois
import requests
import json
from urllib.parse import urlparse

class IoCAnalyzer:
    def __init__(self):
        self.analysis_results = {}
    
    def analyze_ip(self, ip_address):
        """IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®è©³ç´°åˆ†æ"""
        analysis = {
            'ip': ip_address,
            'type': 'ip_address',
            'is_private': False,
            'geolocation': {},
            'reputation': {},
            'reverse_dns': None
        }
        
        try:
            # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆIPã‚¢ãƒ‰ãƒ¬ã‚¹ã®åˆ¤å®š
            ip_obj = ipaddress.ip_address(ip_address)
            analysis['is_private'] = ip_obj.is_private
            
            if not analysis['is_private']:
                # åœ°ç†çš„ä½ç½®æƒ…å ±ã®å–å¾—
                geo_response = requests.get(f'http://ip-api.com/json/{ip_address}')
                if geo_response.status_code == 200:
                    analysis['geolocation'] = geo_response.json()
                
                # é€†å¼•ãDNS
                try:
                    reverse_dns = dns.resolver.resolve_address(ip_address)
                    analysis['reverse_dns'] = str(reverse_dns[0])
                except:
                    pass
                
                # ãƒ¬ãƒ”ãƒ¥ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ç¢ºèªï¼ˆä¾‹ï¼šVirusTotal APIï¼‰
                vt_response = self.check_virustotal_ip(ip_address)
                analysis['reputation'] = vt_response
                
        except Exception as e:
            analysis['error'] = str(e)
        
        return analysis
    
    def analyze_domain(self, domain):
        """ãƒ‰ãƒ¡ã‚¤ãƒ³ã®è©³ç´°åˆ†æ"""
        analysis = {
            'domain': domain,
            'type': 'domain',
            'dns_records': {},
            'whois_info': {},
            'reputation': {},
            'creation_date': None
        }
        
        try:
            # DNS ãƒ¬ã‚³ãƒ¼ãƒ‰ã®å–å¾—
            for record_type in ['A', 'AAAA', 'MX', 'NS', 'TXT']:
                try:
                    records = dns.resolver.resolve(domain, record_type)
                    analysis['dns_records'][record_type] = [str(r) for r in records]
                except:
                    pass
            
            # WHOIS æƒ…å ±ã®å–å¾—
            whois_info = whois.whois(domain)
            analysis['whois_info'] = {
                'registrar': whois_info.registrar,
                'creation_date': str(whois_info.creation_date) if whois_info.creation_date else None,
                'expiration_date': str(whois_info.expiration_date) if whois_info.expiration_date else None,
                'name_servers': whois_info.name_servers
            }
            
            # ãƒ¬ãƒ”ãƒ¥ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ç¢ºèª
            vt_response = self.check_virustotal_domain(domain)
            analysis['reputation'] = vt_response
            
        except Exception as e:
            analysis['error'] = str(e)
        
        return analysis
    
    def analyze_file_hash(self, file_hash):
        """ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ã®è©³ç´°åˆ†æ"""
        analysis = {
            'hash': file_hash,
            'type': 'file_hash',
            'hash_type': self.detect_hash_type(file_hash),
            'malware_families': [],
            'detection_ratio': None,
            'first_seen': None,
            'last_seen': None
        }
        
        # VirusTotal API ã§ãƒãƒ«ã‚¦ã‚§ã‚¢æƒ…å ±ã‚’å–å¾—
        vt_response = self.check_virustotal_hash(file_hash)
        if vt_response:
            analysis.update(vt_response)
        
        return analysis
    
    def detect_hash_type(self, hash_value):
        """ãƒãƒƒã‚·ãƒ¥å€¤ã®ç¨®é¡ã‚’åˆ¤å®š"""
        hash_length = len(hash_value)
        if hash_length == 32:
            return 'MD5'
        elif hash_length == 40:
            return 'SHA1'
        elif hash_length == 64:
            return 'SHA256'
        else:
            return 'Unknown'
    
    def check_virustotal_ip(self, ip_address):
        """VirusTotal APIã§IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®è©•ä¾¡ã‚’ç¢ºèª"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ãªAPI keyãŒå¿…è¦
        api_key = 'your-virustotal-api-key'
        url = f'https://www.virustotal.com/vtapi/v2/ip-address/report'
        params = {'apikey': api_key, 'ip': ip_address}
        
        try:
            response = requests.get(url, params=params)
            if response.status_code == 200:
                return response.json()
        except:
            pass
        
        return {}
    
    def generate_report(self, iocs):
        """IoCåˆ†æãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        report = {
            'analysis_timestamp': datetime.now().isoformat(),
            'total_iocs': len(iocs),
            'analysis_results': [],
            'summary': {
                'high_risk': 0,
                'medium_risk': 0,
                'low_risk': 0,
                'unknown': 0
            }
        }
        
        for ioc in iocs:
            if self.is_ip_address(ioc):
                result = self.analyze_ip(ioc)
            elif self.is_domain(ioc):
                result = self.analyze_domain(ioc)
            elif self.is_hash(ioc):
                result = self.analyze_file_hash(ioc)
            else:
                continue
            
            # ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ã®åˆ¤å®š
            risk_level = self.calculate_risk_level(result)
            result['risk_level'] = risk_level
            report['summary'][risk_level] += 1
            
            report['analysis_results'].append(result)
        
        return report

# ä½¿ç”¨ä¾‹
analyzer = IoCAnalyzer()
iocs = ['192.168.1.100', 'malicious.example.com', 'd41d8cd98f00b204e9800998ecf8427e']
report = analyzer.generate_report(iocs)
print(json.dumps(report, indent=2))
```

## IoCã®å…±æœ‰ã¨æ¨™æº–åŒ–

### 1. æ¨™æº–åŒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

#### STIX/TAXII

```
ğŸ“Š STIXï¼ˆStructured Threat Information eXpressionï¼‰

STIX 2.1 ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¾‹:
{
  "type": "indicator",
  "id": "indicator--12345678-1234-1234-1234-123456789012",
  "created": "2024-01-15T10:00:00.000Z",
  "modified": "2024-01-15T10:00:00.000Z",
  "labels": ["malicious-activity"],
  "pattern": "[file:hashes.SHA256 = 'd6ce0e02d55']",
  "valid_from": "2024-01-15T10:00:00.000Z",
  "kill_chain_phases": [
    {
      "kill_chain_name": "mitre-attack",
      "phase_name": "command-and-control"
    }
  ]
}

TAXIIï¼ˆTrusted Automated eXchange of Intelligence Informationï¼‰:
- STIXãƒ‡ãƒ¼ã‚¿ã®è‡ªå‹•äº¤æ›ãƒ—ãƒ­ãƒˆã‚³ãƒ«
- RESTful API ãƒ™ãƒ¼ã‚¹
- èªè¨¼ãƒ»èªå¯æ©Ÿèƒ½
- å¤§è¦æ¨¡ãªè„…å¨æƒ…å ±å…±æœ‰ã«å¯¾å¿œ
```

#### OpenIOC

```xml
<!-- OpenIOC ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆä¾‹ -->
<OpenIOC xmlns="http://openioc.org/schemas/OpenIOC_1.1">
  <metadata>
    <short_description>Malware Campaign XYZ</short_description>
    <description>IoCs related to malware campaign XYZ</description>
    <authored_by>Security Team</authored_by>
    <authored_date>2024-01-15T10:00:00Z</authored_date>
  </metadata>
  <criteria>
    <Indicator operator="OR" id="12345678-1234-1234-1234-123456789012">
      <IndicatorItem id="item1" condition="is">
        <Context document="FileItem" search="FileItem/Md5sum"/>
        <Content type="md5">d41d8cd98f00b204e9800998ecf8427e</Content>
      </IndicatorItem>
      <IndicatorItem id="item2" condition="contains">
        <Context document="NetworkItem" search="NetworkItem/DNS"/>
        <Content type="string">malicious.example.com</Content>
      </IndicatorItem>
    </Indicator>
  </criteria>
</OpenIOC>
```

### 2. å…±æœ‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 

```
ğŸ¤ IoCå…±æœ‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 

MISPï¼ˆMalware Information Sharing Platformï¼‰:
- ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ã®è„…å¨æƒ…å ±å…±æœ‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
- æ”¿åºœæ©Ÿé–¢ãƒ»ä¼æ¥­ãƒ»ç ”ç©¶æ©Ÿé–¢ã§åºƒãåˆ©ç”¨
- è±Šå¯Œãªãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚µãƒãƒ¼ãƒˆ
- è‡ªå‹•åŒ–APIæä¾›

ThreatConnect:
- å•†ç”¨è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
- é«˜åº¦ãªåˆ†ææ©Ÿèƒ½
- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼è‡ªå‹•åŒ–
- è±Šå¯Œãªå¤–éƒ¨é€£æº

IBM X-Force Exchange:
- IBMæä¾›ã®è„…å¨æƒ…å ±å…±æœ‰ã‚µãƒ¼ãƒ“ã‚¹
- å¤§è¦æ¨¡ãªè„…å¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
- æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹åˆ†æ
- ç„¡æ–™ãƒ»æœ‰æ–™ãƒ—ãƒ©ãƒ³æä¾›

OTXï¼ˆOpen Threat Exchangeï¼‰:
- AlienVaultï¼ˆç¾AT&Tï¼‰æä¾›
- ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ã®æƒ…å ±å…±æœ‰
- ãƒ‘ãƒ«ã‚¹ï¼ˆè„…å¨æƒ…å ±ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ï¼‰æ©Ÿèƒ½
- APIçµŒç”±ã§ã®è‡ªå‹•å–å¾—å¯èƒ½
```

## å®Ÿè·µçš„ãªæ¤œçŸ¥æ‰‹æ³•

### 1. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–

```bash
# ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç³»IoCæ¤œçŸ¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

#!/bin/bash
# network_ioc_monitor.sh

# è¨­å®š
IOC_LIST="malicious_ips.txt"
LOG_FILE="/var/log/ioc_detection.log"
INTERFACE="eth0"

# æ‚ªæ„ã®ã‚ã‚‹IPã‚¢ãƒ‰ãƒ¬ã‚¹ãƒªã‚¹ãƒˆ
MALICIOUS_IPS=(
    "203.0.113.100"
    "198.51.100.50"
    "192.0.2.200"
)

# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–
monitor_network_traffic() {
    tcpdump -i $INTERFACE -n -l | while read line; do
        for malicious_ip in "${MALICIOUS_IPS[@]}"; do
            if echo "$line" | grep -q "$malicious_ip"; then
                echo "[$(date)] ALERT: Communication with malicious IP $malicious_ip detected" | tee -a $LOG_FILE
                echo "Details: $line" | tee -a $LOG_FILE
                
                # è‡ªå‹•ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                # iptables -A INPUT -s $malicious_ip -j DROP
            fi
        done
    done
}

# DNS ã‚¯ã‚¨ãƒªç›£è¦–
monitor_dns_queries() {
    tail -f /var/log/dns.log | while read line; do
        if echo "$line" | grep -E "(malicious\.com|evil\.net|badsite\.org)"; then
            echo "[$(date)] ALERT: DNS query to malicious domain detected" | tee -a $LOG_FILE
            echo "Details: $line" | tee -a $LOG_FILE
        fi
    done
}

# HTTPé€šä¿¡ç›£è¦–
monitor_http_traffic() {
    tcpdump -i $INTERFACE -A -s 0 'tcp port 80' | while read line; do
        if echo "$line" | grep -E "(malware\.exe|trojan\.zip|backdoor\.dll)"; then
            echo "[$(date)] ALERT: Suspicious HTTP request detected" | tee -a $LOG_FILE
            echo "Details: $line" | tee -a $LOG_FILE
        fi
    done
}

# å®Ÿè¡Œ
echo "Starting IoC network monitoring..."
monitor_network_traffic &
monitor_dns_queries &
monitor_http_traffic &

wait
```

### 2. ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–

```python
# ãƒ•ã‚¡ã‚¤ãƒ«ç³»IoCæ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
import os
import hashlib
import time
import json
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class IoCFileMonitor(FileSystemEventHandler):
    def __init__(self, malicious_hashes_file):
        self.malicious_hashes = self.load_malicious_hashes(malicious_hashes_file)
        self.quarantine_dir = "/var/quarantine/"
        
        # æ¤œç–«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆ
        os.makedirs(self.quarantine_dir, exist_ok=True)
    
    def load_malicious_hashes(self, filename):
        """æ‚ªæ„ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿"""
        hashes = set()
        try:
            with open(filename, 'r') as f:
                for line in f:
                    hashes.add(line.strip().lower())
        except FileNotFoundError:
            print(f"Warning: {filename} not found")
        return hashes
    
    def calculate_file_hash(self, filepath):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã®SHA256ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—"""
        sha256_hash = hashlib.sha256()
        try:
            with open(filepath, 'rb') as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest().lower()
        except:
            return None
    
    def quarantine_file(self, filepath):
        """æ‚ªæ„ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç–«"""
        try:
            filename = os.path.basename(filepath)
            quarantine_path = os.path.join(self.quarantine_dir, f"{int(time.time())}_{filename}")
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç–«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•
            os.rename(filepath, quarantine_path)
            
            # æ¤œç–«ãƒ­ã‚°ã®è¨˜éŒ²
            quarantine_log = {
                'timestamp': time.time(),
                'original_path': filepath,
                'quarantine_path': quarantine_path,
                'file_hash': self.calculate_file_hash(quarantine_path),
                'action': 'quarantined'
            }
            
            with open('/var/log/ioc_quarantine.log', 'a') as f:
                f.write(json.dumps(quarantine_log) + '\n')
            
            print(f"[ALERT] Malicious file quarantined: {filepath} -> {quarantine_path}")
            
        except Exception as e:
            print(f"Error quarantining file {filepath}: {e}")
    
    def on_created(self, event):
        """æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚ã®å‡¦ç†"""
        if not event.is_directory:
            self.check_file_ioc(event.src_path)
    
    def on_modified(self, event):
        """ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ™‚ã®å‡¦ç†"""
        if not event.is_directory:
            self.check_file_ioc(event.src_path)
    
    def check_file_ioc(self, filepath):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã®IoCãƒã‚§ãƒƒã‚¯"""
        try:
            # ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ã®è¨ˆç®—
            file_hash = self.calculate_file_hash(filepath)
            if not file_hash:
                return
            
            # æ‚ªæ„ã®ã‚ã‚‹ãƒãƒƒã‚·ãƒ¥ã¨ã®ç…§åˆ
            if file_hash in self.malicious_hashes:
                print(f"[ALERT] Malicious file detected: {filepath}")
                print(f"Hash: {file_hash}")
                
                # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç–«
                self.quarantine_file(filepath)
                
                # ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥ï¼ˆãƒ¡ãƒ¼ãƒ«ã€Slackç­‰ï¼‰
                self.send_alert(filepath, file_hash)
            
            # ãƒ•ã‚¡ã‚¤ãƒ«åã«ã‚ˆã‚‹æ¤œçŸ¥
            filename = os.path.basename(filepath).lower()
            suspicious_names = [
                'invoice.pdf.exe',
                'document.doc.exe',
                'photo.jpg.exe',
                'update.exe',
                'codec.exe'
            ]
            
            for suspicious_name in suspicious_names:
                if suspicious_name in filename:
                    print(f"[WARNING] Suspicious filename detected: {filepath}")
                    # è©³ç´°åˆ†æã®ãŸã‚ã®ãƒ­ã‚°è¨˜éŒ²
                    self.log_suspicious_file(filepath, "suspicious_filename")
        
        except Exception as e:
            print(f"Error checking file {filepath}: {e}")
    
    def send_alert(self, filepath, file_hash):
        """ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥ã®é€ä¿¡"""
        alert_data = {
            'timestamp': time.time(),
            'alert_type': 'malicious_file_detected',
            'filepath': filepath,
            'file_hash': file_hash,
            'hostname': os.uname().nodename
        }
        
        # ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²
        with open('/var/log/ioc_alerts.log', 'a') as f:
            f.write(json.dumps(alert_data) + '\n')
        
        # å¤–éƒ¨é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã¸ã®é€ä¿¡ï¼ˆå®Ÿè£…ä¾‹ï¼‰
        # send_to_siem(alert_data)
        # send_slack_notification(alert_data)
        # send_email_alert(alert_data)

def main():
    # ç›£è¦–å¯¾è±¡ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    watch_directories = [
        "/home/",
        "/tmp/",
        "/var/tmp/",
        "/Downloads/",
        "/Users/"
    ]
    
    # IoCç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
    event_handler = IoCFileMonitor('malicious_hashes.txt')
    observer = Observer()
    
    # ç›£è¦–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®è¨­å®š
    for directory in watch_directories:
        if os.path.exists(directory):
            observer.schedule(event_handler, directory, recursive=True)
            print(f"Monitoring directory: {directory}")
    
    # ç›£è¦–é–‹å§‹
    observer.start()
    print("IoC file monitoring started...")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("IoC file monitoring stopped.")
    
    observer.join()

if __name__ == "__main__":
    main()
```

## ãƒ„ãƒ¼ãƒ«ã¨æŠ€è¡“

### 1. ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ãƒ„ãƒ¼ãƒ«

```
ğŸ”§ ä¸»è¦ãªã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹IoCãƒ„ãƒ¼ãƒ«

YARA:
- ãƒãƒ«ã‚¦ã‚§ã‚¢æ¤œçŸ¥ãƒ«ãƒ¼ãƒ«ä½œæˆãƒ„ãƒ¼ãƒ«
- ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³
- æŸ”è»Ÿãªãƒ«ãƒ¼ãƒ«è¨˜è¿°
- é«˜é€Ÿã‚¹ã‚­ãƒ£ãƒ³æ©Ÿèƒ½

ä½¿ç”¨ä¾‹:
rule Malware_Example {
    meta:
        description = "Detects Example Malware"
        author = "Security Team"
        date = "2024-01-15"
    
    strings:
        $string1 = "malicious_string_1"
        $string2 = { 6D 61 6C 77 61 72 65 }
        $regex1 = /http:\/\/[a-z]+\.evil\.com/
    
    condition:
        $string1 or $string2 or $regex1
}

Suricata:
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¾µå…¥æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
- é«˜æ€§èƒ½ãƒ‘ã‚±ãƒƒãƒˆå‡¦ç†
- Lua ã‚¹ã‚¯ãƒªãƒ—ãƒˆå¯¾å¿œ
- JSONå‡ºåŠ›å¯¾å¿œ

Snort:
- è€èˆ—ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¾µå…¥æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
- è±Šå¯Œãªãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆ
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œçŸ¥
- ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ç‰ˆã¨å•†ç”¨ç‰ˆ

TheHive:
- ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
- IoCç®¡ç†æ©Ÿèƒ½
- ã‚±ãƒ¼ã‚¹ç®¡ç†
- åˆ†æãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
```

### 2. å•†ç”¨ãƒ„ãƒ¼ãƒ«

```
ğŸ’¼ ä¸»è¦ãªå•†ç”¨IoCã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³

Splunk:
- å¤§è¦æ¨¡ãƒ­ã‚°åˆ†æãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œç´¢ãƒ»åˆ†æ
- æ©Ÿæ¢°å­¦ç¿’æ©Ÿèƒ½
- è±Šå¯Œãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

QRadar (IBM):
- SIEM/SOARçµ±åˆãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
- é«˜åº¦ãªç›¸é–¢åˆ†æ
- è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹çµ±åˆ
- è‡ªå‹•åŒ–å¯¾å¿œ

ArcSight (Micro Focus):
- ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºSIEM
- å¤§è¦æ¨¡ç’°å¢ƒå¯¾å¿œ
- é«˜åº¦ãªãƒ«ãƒ¼ãƒ«ã‚¨ãƒ³ã‚¸ãƒ³
- ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å¯¾å¿œ

Phantom (Splunk):
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
- ãƒ—ãƒ¬ã‚¤ãƒ–ãƒƒã‚¯è‡ªå‹•å®Ÿè¡Œ
- IoC ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆ
- ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œè‡ªå‹•åŒ–
```

### 3. ã‚¯ãƒ©ã‚¦ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹

```
â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ™ãƒ¼ã‚¹ã®IoCã‚µãƒ¼ãƒ“ã‚¹

VirusTotal:
- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»URLãƒ»IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®è©•ä¾¡
- è¤‡æ•°ã®ã‚¢ãƒ³ãƒã‚¦ã‚¤ãƒ«ã‚¹ã‚¨ãƒ³ã‚¸ãƒ³
- ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‹ã‚‰ã®æƒ…å ±
- APIæä¾›

Hybrid Analysis:
- å‹•çš„ãƒãƒ«ã‚¦ã‚§ã‚¢è§£æ
- ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹å®Ÿè¡Œ
- è©³ç´°ãªè¡Œå‹•åˆ†æ
- IoCè‡ªå‹•æŠ½å‡º

URLVoid:
- URLãƒ»ãƒ‰ãƒ¡ã‚¤ãƒ³ã®è©•ä¾¡
- è¤‡æ•°ã®ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆç¢ºèª
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œæŸ»
- APIæä¾›

ThreatMiner:
- è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ãƒãƒ¼ã‚¿ãƒ«
- IoCæ¤œç´¢ãƒ»åˆ†æ
- é–¢é€£æ€§åˆ†æ
- ç„¡æ–™åˆ©ç”¨å¯èƒ½
```

## è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹

### 1. è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ã¨IoC

```
ğŸ§  è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ã®éšå±¤

æˆ¦ç•¥çš„ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹:
- é•·æœŸçš„ãªè„…å¨ãƒˆãƒ¬ãƒ³ãƒ‰
- æ”»æ’ƒè€…ã‚°ãƒ«ãƒ¼ãƒ—ã®å‹•å‘
- æ¥­ç•Œå›ºæœ‰ã®è„…å¨
- åœ°æ”¿å­¦çš„å½±éŸ¿

æˆ¦è¡“çš„ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹:
- æ”»æ’ƒæ‰‹æ³•ï¼ˆTTPï¼‰
- ãƒãƒ«ã‚¦ã‚§ã‚¢ãƒ•ã‚¡ãƒŸãƒªãƒ¼
- æ”»æ’ƒã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³
- è„…å¨ã‚¢ã‚¯ã‚¿ãƒ¼ã®ç‰¹å¾´

æŠ€è¡“çš„ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹:
- IoCï¼ˆæœ¬è¨˜äº‹ã®ç„¦ç‚¹ï¼‰
- ãƒãƒ«ã‚¦ã‚§ã‚¢ã‚µãƒ³ãƒ—ãƒ«
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç½²å
- YARA ãƒ«ãƒ¼ãƒ«

é‹ç”¨çš„ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹:
- é€²è¡Œä¸­ã®æ”»æ’ƒ
- ç·Šæ€¥å¯¾å¿œæƒ…å ±
- æ”»æ’ƒäºˆæ¸¬
- å¯¾ç­–ã®æœ‰åŠ¹æ€§
```

### 2. ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ã‚µã‚¤ã‚¯ãƒ«

```
ğŸ”„ ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ã‚µã‚¤ã‚¯ãƒ«ã¨IoC

1. è¦ä»¶å®šç¾©ï¼ˆRequirementsï¼‰
   - çµ„ç¹”ã®è„…å¨ãƒ¢ãƒ‡ãƒ«å®šç¾©
   - ä¿è­·ã™ã¹ãè³‡ç”£ã®ç‰¹å®š
   - è„…å¨ã‚¢ã‚¯ã‚¿ãƒ¼ã®å„ªå…ˆé †ä½
   - å¿…è¦ãªIoCã‚¿ã‚¤ãƒ—ã®æ±ºå®š

2. åé›†ï¼ˆCollectionï¼‰
   - å†…éƒ¨ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®IoCåé›†
   - å¤–éƒ¨ãƒ•ã‚£ãƒ¼ãƒ‰ã®æ´»ç”¨
   - OSINTï¼ˆã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ï¼‰
   - æ¥­ç•Œæƒ…å ±å…±æœ‰

3. å‡¦ç†ãƒ»åˆ†æï¼ˆProcessing & Analysisï¼‰
   - ãƒ‡ãƒ¼ã‚¿ã®æ­£è¦åŒ–ãƒ»æ¨™æº–åŒ–
   - ä¿¡é ¼åº¦è©•ä¾¡
   - é–¢é€£æ€§åˆ†æ
   - è„…å¨ãƒ¬ãƒ™ãƒ«åˆ¤å®š

4. é…å¸ƒï¼ˆDisseminationï¼‰
   - é–¢ä¿‚è€…ã¸ã®æƒ…å ±å…±æœ‰
   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ„ãƒ¼ãƒ«ã¸ã®é…ä¿¡
   - ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥
   - ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ

5. ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆFeedbackï¼‰
   - æ¤œçŸ¥çµæœã®è©•ä¾¡
   - èª¤æ¤œçŸ¥ç‡ã®åˆ†æ
   - æ”¹å–„ç‚¹ã®ç‰¹å®š
   - è¦ä»¶ã®è¦‹ç›´ã—
```

## ã‚ˆãã‚ã‚‹èª²é¡Œã¨å¯¾ç­–

### 1. èª¤æ¤œçŸ¥ã®å•é¡Œ

```
âš ï¸ èª¤æ¤œçŸ¥ï¼ˆFalse Positiveï¼‰ã¸ã®å¯¾å¿œ

åŸå› :
- ä¿¡é ¼åº¦ã®ä½ã„IoCä½¿ç”¨
- æ–‡è„ˆã‚’è€ƒæ…®ã—ãªã„åˆ¤å®š
- å¤ã„IoCæƒ…å ±ã®ä½¿ç”¨
- æ­£å¸¸ãªé€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®æ··åŒ

å¯¾ç­–:
1. å¤šå±¤é˜²å¾¡ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
   â–¡ è¤‡æ•°ã®IoCã‚½ãƒ¼ã‚¹ã‚’æ´»ç”¨
   â–¡ ä¿¡é ¼åº¦ã«ã‚ˆã‚‹é‡ã¿ä»˜ã‘
   â–¡ æ™‚é–“çµŒéã«ã‚ˆã‚‹ä¿¡é ¼åº¦æ¸›è¡°
   â–¡ ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã¨ã®ç…§åˆ

2. æ–‡è„ˆã‚’è€ƒæ…®ã—ãŸåˆ†æ
   â–¡ é€šä¿¡ã®é »åº¦ãƒ»ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
   â–¡ ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ã¨ã®é–¢é€£æ€§
   â–¡ æ¥­å‹™ã‚·ã‚¹ãƒ†ãƒ ã¨ã®ç…§åˆ
   â–¡ åœ°ç†çš„ãƒ»æ™‚é–“çš„ãªå¦¥å½“æ€§

3. ç¶™ç¶šçš„ãªèª¿æ•´
   â–¡ å®šæœŸçš„ãªèª¤æ¤œçŸ¥ç‡è©•ä¾¡
   â–¡ ãƒ«ãƒ¼ãƒ«ã®ç¶™ç¶šçš„æ”¹å–„
   â–¡ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã®æ§‹ç¯‰
   â–¡ æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹æœ€é©åŒ–
```

#### èª¤æ¤œçŸ¥å¯¾ç­–ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¾‹

```python
# èª¤æ¤œçŸ¥å¯¾ç­–ã‚’å«ã‚€IoCæ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
import time
import json
from collections import defaultdict, deque
from datetime import datetime, timedelta

class SmartIoCDetector:
    def __init__(self):
        self.ioc_database = {}
        self.whitelist = set()
        self.detection_history = defaultdict(deque)
        self.confidence_threshold = 0.7
        self.time_decay_factor = 0.95
        
    def load_whitelist(self, whitelist_file):
        """ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã®èª­ã¿è¾¼ã¿"""
        try:
            with open(whitelist_file, 'r') as f:
                for line in f:
                    self.whitelist.add(line.strip().lower())
        except FileNotFoundError:
            print(f"Whitelist file {whitelist_file} not found")
    
    def add_ioc(self, ioc_value, ioc_type, confidence, source, context=None):
        """IoCæƒ…å ±ã®è¿½åŠ ï¼ˆä¿¡é ¼åº¦ä»˜ãï¼‰"""
        self.ioc_database[ioc_value] = {
            'type': ioc_type,
            'confidence': confidence,
            'source': source,
            'first_seen': datetime.now(),
            'last_updated': datetime.now(),
            'context': context or {},
            'detection_count': 0,
            'false_positive_count': 0
        }
    
    def update_confidence(self, ioc_value, is_true_positive):
        """æ¤œçŸ¥çµæœã«åŸºã¥ãä¿¡é ¼åº¦ã®æ›´æ–°"""
        if ioc_value in self.ioc_database:
            ioc_data = self.ioc_database[ioc_value]
            
            if is_true_positive:
                # çœŸé™½æ€§ã®å ´åˆã€ä¿¡é ¼åº¦ã‚’ä¸Šã’ã‚‹
                ioc_data['confidence'] = min(1.0, ioc_data['confidence'] * 1.1)
                ioc_data['detection_count'] += 1
            else:
                # å½é™½æ€§ã®å ´åˆã€ä¿¡é ¼åº¦ã‚’ä¸‹ã’ã‚‹
                ioc_data['confidence'] = max(0.1, ioc_data['confidence'] * 0.8)
                ioc_data['false_positive_count'] += 1
            
            ioc_data['last_updated'] = datetime.now()
    
    def apply_time_decay(self):
        """æ™‚é–“çµŒéã«ã‚ˆã‚‹ä¿¡é ¼åº¦ã®æ¸›è¡°"""
        current_time = datetime.now()
        
        for ioc_value, ioc_data in self.ioc_database.items():
            days_since_update = (current_time - ioc_data['last_updated']).days
            
            if days_since_update > 0:
                decay_factor = self.time_decay_factor ** days_since_update
                ioc_data['confidence'] *= decay_factor
    
    def check_ioc(self, value, additional_context=None):
        """IoC ãƒã‚§ãƒƒã‚¯ï¼ˆèª¤æ¤œçŸ¥å¯¾ç­–ä»˜ãï¼‰"""
        # ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆãƒã‚§ãƒƒã‚¯
        if value.lower() in self.whitelist:
            return {
                'is_malicious': False,
                'reason': 'whitelisted',
                'confidence': 0.0
            }
        
        # IoC ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ã®æ¤œç´¢
        if value not in self.ioc_database:
            return {
                'is_malicious': False,
                'reason': 'not_found',
                'confidence': 0.0
            }
        
        ioc_data = self.ioc_database[value]
        
        # æ™‚é–“æ¸›è¡°ã®é©ç”¨
        self.apply_time_decay()
        
        # æ–‡è„ˆã«ã‚ˆã‚‹ä¿¡é ¼åº¦èª¿æ•´
        adjusted_confidence = self.adjust_confidence_by_context(
            ioc_data, additional_context
        )
        
        # é–¾å€¤ã«ã‚ˆã‚‹åˆ¤å®š
        is_malicious = adjusted_confidence >= self.confidence_threshold
        
        # æ¤œçŸ¥å±¥æ­´ã®è¨˜éŒ²
        detection_record = {
            'timestamp': datetime.now(),
            'value': value,
            'confidence': adjusted_confidence,
            'context': additional_context,
            'decision': is_malicious
        }
        
        self.detection_history[value].append(detection_record)
        
        # å±¥æ­´ã®åˆ¶é™ï¼ˆæœ€æ–°100ä»¶ã®ã¿ä¿æŒï¼‰
        if len(self.detection_history[value]) > 100:
            self.detection_history[value].popleft()
        
        return {
            'is_malicious': is_malicious,
            'confidence': adjusted_confidence,
            'reason': 'ioc_match' if is_malicious else 'low_confidence',
            'source': ioc_data['source'],
            'detection_history': list(self.detection_history[value])[-5:]  # æœ€æ–°5ä»¶
        }
    
    def adjust_confidence_by_context(self, ioc_data, context):
        """æ–‡è„ˆã«ã‚ˆã‚‹ä¿¡é ¼åº¦èª¿æ•´"""
        base_confidence = ioc_data['confidence']
        
        if not context:
            return base_confidence
        
        # æ™‚é–“å¸¯ã«ã‚ˆã‚‹èª¿æ•´
        current_hour = datetime.now().hour
        if 'business_hours_only' in ioc_data.get('context', {}):
            if 9 <= current_hour <= 17:
                base_confidence *= 0.7  # æ¥­å‹™æ™‚é–“ä¸­ã¯ä¿¡é ¼åº¦ã‚’ä¸‹ã’ã‚‹
        
        # åœ°ç†çš„ä½ç½®ã«ã‚ˆã‚‹èª¿æ•´
        if 'source_country' in context and 'expected_countries' in ioc_data.get('context', {}):
            if context['source_country'] in ioc_data['context']['expected_countries']:
                base_confidence *= 0.8  # æœŸå¾…ã•ã‚Œã‚‹å›½ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ä¿¡é ¼åº¦ã‚’ä¸‹ã’ã‚‹
        
        # é€šä¿¡é »åº¦ã«ã‚ˆã‚‹èª¿æ•´
        if 'frequency' in context:
            if context['frequency'] == 'high':
                base_confidence *= 1.2  # é«˜é »åº¦é€šä¿¡ã¯ä¿¡é ¼åº¦ã‚’ä¸Šã’ã‚‹
            elif context['frequency'] == 'single':
                base_confidence *= 0.9  # å˜ç™ºé€šä¿¡ã¯ä¿¡é ¼åº¦ã‚’ä¸‹ã’ã‚‹
        
        return min(1.0, max(0.0, base_confidence))
    
    def generate_statistics(self):
        """æ¤œçŸ¥çµ±è¨ˆã®ç”Ÿæˆ"""
        total_iocs = len(self.ioc_database)
        high_confidence = sum(1 for ioc in self.ioc_database.values() if ioc['confidence'] >= 0.8)
        medium_confidence = sum(1 for ioc in self.ioc_database.values() if 0.5 <= ioc['confidence'] < 0.8)
        low_confidence = sum(1 for ioc in self.ioc_database.values() if ioc['confidence'] < 0.5)
        
        total_detections = sum(len(history) for history in self.detection_history.values())
        
        return {
            'total_iocs': total_iocs,
            'high_confidence_iocs': high_confidence,
            'medium_confidence_iocs': medium_confidence,
            'low_confidence_iocs': low_confidence,
            'total_detections': total_detections,
            'average_confidence': sum(ioc['confidence'] for ioc in self.ioc_database.values()) / total_iocs if total_iocs > 0 else 0
        }

# ä½¿ç”¨ä¾‹
detector = SmartIoCDetector()
detector.load_whitelist('whitelist.txt')

# IoC ã®è¿½åŠ 
detector.add_ioc('192.168.1.100', 'ip', 0.9, 'threat_feed_a')
detector.add_ioc('malicious.com', 'domain', 0.8, 'threat_feed_b')

# æ¤œçŸ¥ãƒ†ã‚¹ãƒˆ
result = detector.check_ioc('192.168.1.100', {'source_country': 'US', 'frequency': 'high'})
print(f"Detection result: {result}")

# çµ±è¨ˆæƒ…å ±
stats = detector.generate_statistics()
print(f"Statistics: {stats}")
```

### 2. IoCæƒ…å ±ã®é®®åº¦ç®¡ç†

```
â° IoCæƒ…å ±ã®æ™‚åŠ¹æ€§ç®¡ç†

èª²é¡Œ:
- å¤ã„IoCæƒ…å ±ã«ã‚ˆã‚‹èª¤æ¤œçŸ¥
- æ”»æ’ƒè€…ã®ã‚¤ãƒ³ãƒ•ãƒ©å¤‰æ›´
- æ­£å½“ãªã‚µãƒ¼ãƒ“ã‚¹ã¸ã®è»¢ç”¨
- æƒ…å ±ã®ä¿¡é ¼æ€§ä½ä¸‹

å¯¾ç­–:
1. ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†
   â–¡ IoC ã®æœ‰åŠ¹æœŸé™è¨­å®š
   â–¡ å®šæœŸçš„ãªå†è©•ä¾¡
   â–¡ è‡ªå‹•çš„ãªä¿¡é ¼åº¦æ¸›è¡°
   â–¡ æœŸé™åˆ‡ã‚ŒIoCã®è‡ªå‹•å‰Šé™¤

2. å‹•çš„æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ 
   â–¡ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ•ã‚£ãƒ¼ãƒ‰é€£æº
   â–¡ è‡ªå‹•æ›´æ–°æ©Ÿèƒ½
   â–¡ å¤‰æ›´å±¥æ­´ã®è¨˜éŒ²
   â–¡ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½

3. å“è³ªç®¡ç†
   â–¡ ã‚½ãƒ¼ã‚¹åˆ¥ä¿¡é ¼åº¦ç®¡ç†
   â–¡ æ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã®å®Ÿè£…
   â–¡ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—
   â–¡ ç¶™ç¶šçš„æ”¹å–„
```

### 3. ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã®èª²é¡Œ

```
ğŸ“ˆ å¤§è¦æ¨¡ç’°å¢ƒã§ã®IoCç®¡ç†

èª²é¡Œ:
- å¤§é‡ã®IoCãƒ‡ãƒ¼ã‚¿å‡¦ç†
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œçŸ¥ã®æ€§èƒ½è¦ä»¶
- ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ã®åˆ¶ç´„
- æ¤œç´¢é€Ÿåº¦ã®æœ€é©åŒ–

å¯¾ç­–:
1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–
   â–¡ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æœ€é©åŒ–
   â–¡ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ‹ãƒ³ã‚°
   â–¡ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æ´»ç”¨
   â–¡ åˆ†æ•£ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹

2. å‡¦ç†ã®åŠ¹ç‡åŒ–
   â–¡ ä¸¦åˆ—å‡¦ç†ã®å®Ÿè£…
   â–¡ ãƒãƒƒãƒå‡¦ç†ã®æ´»ç”¨
   â–¡ ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†
   â–¡ è² è·åˆ†æ•£

3. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ
   â–¡ ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–
   â–¡ ã‚¯ãƒ©ã‚¦ãƒ‰æ´»ç”¨
   â–¡ CDN ã®åˆ©ç”¨
   â–¡ ã‚¨ãƒƒã‚¸ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
```

## å®Ÿè£…ä¾‹ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. ä¼æ¥­å†…IoCç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

```python
# ä¼æ¥­å†…IoCç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ä¾‹
import sqlite3
import json
import hashlib
import requests
import schedule
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional

class EnterpriseIoCManager:
    def __init__(self, db_path='ioc_database.db'):
        self.db_path = db_path
        self.init_database()
        self.threat_feeds = []
        self.detection_rules = {}
        
    def init_database(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆæœŸåŒ–"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # IoC ãƒ†ãƒ¼ãƒ–ãƒ«
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS iocs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                value TEXT UNIQUE NOT NULL,
                type TEXT NOT NULL,
                confidence REAL NOT NULL,
                source TEXT NOT NULL,
                first_seen DATETIME NOT NULL,
                last_seen DATETIME NOT NULL,
                last_updated DATETIME NOT NULL,
                detection_count INTEGER DEFAULT 0,
                false_positive_count INTEGER DEFAULT 0,
                context TEXT,
                tags TEXT,
                is_active BOOLEAN DEFAULT 1
            )
        ''')
        
        # æ¤œçŸ¥å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS detections (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ioc_value TEXT NOT NULL,
                timestamp DATETIME NOT NULL,
                source_system TEXT NOT NULL,
                context TEXT,
                is_blocked BOOLEAN DEFAULT 0,
                analyst_verified BOOLEAN DEFAULT 0,
                FOREIGN KEY (ioc_value) REFERENCES iocs (value)
            )
        ''')
        
        # è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS threat_feeds (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                url TEXT NOT NULL,
                api_key TEXT,
                last_updated DATETIME,
                is_active BOOLEAN DEFAULT 1,
                update_interval INTEGER DEFAULT 3600
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def add_threat_feed(self, name: str, url: str, api_key: str = None, update_interval: int = 3600):
        """è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰ã®è¿½åŠ """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO threat_feeds 
            (name, url, api_key, update_interval) 
            VALUES (?, ?, ?, ?)
        ''', (name, url, api_key, update_interval))
        
        conn.commit()
        conn.close()
    
    def add_ioc(self, value: str, ioc_type: str, confidence: float, 
                source: str, context: Dict = None, tags: List[str] = None):
        """IoC ã®è¿½åŠ ãƒ»æ›´æ–°"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        current_time = datetime.now()
        context_json = json.dumps(context) if context else None
        tags_json = json.dumps(tags) if tags else None
        
        # æ—¢å­˜ã®IoCã‹ãƒã‚§ãƒƒã‚¯
        cursor.execute('SELECT * FROM iocs WHERE value = ?', (value,))
        existing = cursor.fetchone()
        
        if existing:
            # æ—¢å­˜ã®IoCã‚’æ›´æ–°
            cursor.execute('''
                UPDATE iocs 
                SET confidence = ?, source = ?, last_seen = ?, 
                    last_updated = ?, context = ?, tags = ?
                WHERE value = ?
            ''', (confidence, source, current_time, current_time, 
                  context_json, tags_json, value))
        else:
            # æ–°ã—ã„IoCã‚’è¿½åŠ 
            cursor.execute('''
                INSERT INTO iocs 
                (value, type, confidence, source, first_seen, last_seen, 
                 last_updated, context, tags) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (value, ioc_type, confidence, source, current_time, 
                  current_time, current_time, context_json, tags_json))
        
        conn.commit()
        conn.close()
    
    def check_ioc(self, value: str, context: Dict = None) -> Dict:
        """IoC ãƒã‚§ãƒƒã‚¯"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM iocs 
            WHERE value = ? AND is_active = 1
        ''', (value,))
        
        result = cursor.fetchone()
        conn.close()
        
        if not result:
            return {'is_malicious': False, 'confidence': 0.0, 'reason': 'not_found'}
        
        # ã‚«ãƒ©ãƒ åã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚è¾æ›¸ã«å¤‰æ›
        columns = ['id', 'value', 'type', 'confidence', 'source', 'first_seen', 
                  'last_seen', 'last_updated', 'detection_count', 
                  'false_positive_count', 'context', 'tags', 'is_active']
        ioc_data = dict(zip(columns, result))
        
        # æ™‚é–“æ¸›è¡°ã®é©ç”¨
        days_old = (datetime.now() - datetime.fromisoformat(ioc_data['last_updated'])).days
        time_decay = 0.95 ** days_old
        adjusted_confidence = ioc_data['confidence'] * time_decay
        
        # æ¤œçŸ¥ã‚’è¨˜éŒ²
        self.record_detection(value, context)
        
        is_malicious = adjusted_confidence >= 0.7
        
        return {
            'is_malicious': is_malicious,
            'confidence': adjusted_confidence,
            'original_confidence': ioc_data['confidence'],
            'source': ioc_data['source'],
            'type': ioc_data['type'],
            'first_seen': ioc_data['first_seen'],
            'detection_count': ioc_data['detection_count'],
            'tags': json.loads(ioc_data['tags']) if ioc_data['tags'] else []
        }
    
    def record_detection(self, ioc_value: str, context: Dict = None, 
                        source_system: str = 'unknown'):
        """æ¤œçŸ¥ã®è¨˜éŒ²"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        context_json = json.dumps(context) if context else None
        
        cursor.execute('''
            INSERT INTO detections 
            (ioc_value, timestamp, source_system, context) 
            VALUES (?, ?, ?, ?)
        ''', (ioc_value, datetime.now(), source_system, context_json))
        
        # IoC ã®æ¤œçŸ¥ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
        cursor.execute('''
            UPDATE iocs 
            SET detection_count = detection_count + 1, last_seen = ?
            WHERE value = ?
        ''', (datetime.now(), ioc_value))
        
        conn.commit()
        conn.close()
    
    def update_from_threat_feeds(self):
        """è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰ã‹ã‚‰ã®IoCæ›´æ–°"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM threat_feeds WHERE is_active = 1')
        feeds = cursor.fetchall()
        conn.close()
        
        for feed in feeds:
            feed_name, feed_url, api_key = feed[1], feed[2], feed[3]
            
            try:
                # ãƒ•ã‚£ãƒ¼ãƒ‰ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                headers = {}
                if api_key:
                    headers['Authorization'] = f'Bearer {api_key}'
                
                response = requests.get(feed_url, headers=headers, timeout=30)
                if response.status_code == 200:
                    threat_data = response.json()
                    
                    # IoC ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
                    for indicator in threat_data.get('indicators', []):
                        self.add_ioc(
                            value=indicator['value'],
                            ioc_type=indicator['type'],
                            confidence=indicator.get('confidence', 0.5),
                            source=feed_name,
                            context=indicator.get('context'),
                            tags=indicator.get('tags')
                        )
                    
                    print(f"Updated {len(threat_data.get('indicators', []))} IoCs from {feed_name}")
                    
            except Exception as e:
                print(f"Error updating from feed {feed_name}: {e}")
    
    def cleanup_old_iocs(self, days_old: int = 90):
        """å¤ã„IoCã®å‰Šé™¤"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cutoff_date = datetime.now() - timedelta(days=days_old)
        
        cursor.execute('''
            UPDATE iocs 
            SET is_active = 0 
            WHERE last_updated < ? AND confidence < 0.3
        ''', (cutoff_date,))
        
        deleted_count = cursor.rowcount
        conn.commit()
        conn.close()
        
        print(f"Deactivated {deleted_count} old IoCs")
        return deleted_count
    
    def generate_report(self, days: int = 7) -> Dict:
        """IoC ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # åŸºæœ¬çµ±è¨ˆ
        cursor.execute('SELECT COUNT(*) FROM iocs WHERE is_active = 1')
        total_active_iocs = cursor.fetchone()[0]
        
        cursor.execute('SELECT type, COUNT(*) FROM iocs WHERE is_active = 1 GROUP BY type')
        iocs_by_type = dict(cursor.fetchall())
        
        # æœ€è¿‘ã®æ¤œçŸ¥çµ±è¨ˆ
        cutoff_date = datetime.now() - timedelta(days=days)
        cursor.execute('''
            SELECT COUNT(*) FROM detections 
            WHERE timestamp > ?
        ''', (cutoff_date,))
        recent_detections = cursor.fetchone()[0]
        
        # ä¸Šä½æ¤œçŸ¥IoC
        cursor.execute('''
            SELECT i.value, i.type, i.source, COUNT(d.id) as detection_count
            FROM iocs i
            JOIN detections d ON i.value = d.ioc_value
            WHERE d.timestamp > ?
            GROUP BY i.value
            ORDER BY detection_count DESC
            LIMIT 10
        ''', (cutoff_date,))
        top_detected_iocs = cursor.fetchall()
        
        conn.close()
        
        return {
            'report_period_days': days,
            'total_active_iocs': total_active_iocs,
            'iocs_by_type': iocs_by_type,
            'recent_detections': recent_detections,
            'top_detected_iocs': [
                {
                    'value': row[0],
                    'type': row[1],
                    'source': row[2],
                    'detection_count': row[3]
                }
                for row in top_detected_iocs
            ]
        }
    
    def start_scheduler(self):
        """å®šæœŸå®Ÿè¡Œã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã®é–‹å§‹"""
        # è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰ã®æ›´æ–°ï¼ˆ1æ™‚é–“ã”ã¨ï¼‰
        schedule.every().hour.do(self.update_from_threat_feeds)
        
        # å¤ã„IoCã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆ1æ—¥1å›ï¼‰
        schedule.every().day.at("02:00").do(self.cleanup_old_iocs)
        
        print("IoC Manager scheduler started...")
        while True:
            schedule.run_pending()
            time.sleep(60)

# ä½¿ç”¨ä¾‹
def main():
    # IoCç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
    ioc_manager = EnterpriseIoCManager()
    
    # è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰ã®è¨­å®š
    ioc_manager.add_threat_feed(
        name="Internal Threat Feed",
        url="https://internal-threat-feed.company.com/api/v1/indicators",
        api_key="your-api-key"
    )
    
    # æ‰‹å‹•ã§IoCã‚’è¿½åŠ 
    ioc_manager.add_ioc(
        value="192.168.1.100",
        ioc_type="ip",
        confidence=0.9,
        source="manual_analysis",
        context={"campaign": "apt-example"},
        tags=["apt", "c2-server"]
    )
    
    # IoC ãƒã‚§ãƒƒã‚¯
    result = ioc_manager.check_ioc("192.168.1.100")
    print(f"IoC check result: {result}")
    
    # ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    report = ioc_manager.generate_report(days=30)
    print(f"Monthly report: {json.dumps(report, indent=2)}")
    
    # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼é–‹å§‹ï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ï¼‰
    # ioc_manager.start_scheduler()

if __name__ == "__main__":
    main()
```

## ã¾ã¨ã‚

### IoCæ´»ç”¨ã®æˆåŠŸè¦å› 

```
âœ… IoCå®Ÿè£…ãƒ»é‹ç”¨ã®é‡è¦ãƒã‚¤ãƒ³ãƒˆ

æŠ€è¡“çš„è¦å› :
â–¡ é©åˆ‡ãªãƒ‡ãƒ¼ã‚¿å“è³ªç®¡ç†
â–¡ åŠ¹ç‡çš„ãªæ¤œç´¢ãƒ»ç…§åˆã‚·ã‚¹ãƒ†ãƒ 
â–¡ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†èƒ½åŠ›
â–¡ ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

é‹ç”¨çš„è¦å› :
â–¡ ç¶™ç¶šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰æ›´æ–°
â–¡ èª¤æ¤œçŸ¥ç‡ã®æœ€é©åŒ–
â–¡ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã¨ã®é€£æº
â–¡ å®šæœŸçš„ãªåŠ¹æœæ¸¬å®š

çµ„ç¹”çš„è¦å› :
â–¡ æ˜ç¢ºãªè²¬ä»»ä½“åˆ¶
â–¡ é©åˆ‡ãªã‚¹ã‚­ãƒ«ãƒ»ãƒªã‚½ãƒ¼ã‚¹
â–¡ å¤–éƒ¨ã¨ã®æƒ…å ±å…±æœ‰
â–¡ ç¶™ç¶šçš„ãªæ”¹å–„æ–‡åŒ–
```

### ä»Šå¾Œã®å‹•å‘

```
ğŸ”® IoCæŠ€è¡“ã®å°†æ¥å±•æœ›

æŠ€è¡“çš„é€²åŒ–:
- AI/ML ã«ã‚ˆã‚‹è‡ªå‹•IoCç”Ÿæˆ
- è¡Œå‹•åˆ†æãƒ™ãƒ¼ã‚¹ã®æ¤œçŸ¥
- ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã‚ˆã‚‹é–¢é€£æ€§åˆ†æ
- é‡å­æš—å·æ™‚ä»£ã¸ã®å¯¾å¿œ

æ¨™æº–åŒ–å‹•å‘:
- STIX/TAXII ã®æ›´ãªã‚‹æ™®åŠ
- æ¥­ç•Œæ¨ªæ–­çš„ãªæƒ…å ±å…±æœ‰
- è‡ªå‹•åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®æ¨™æº–åŒ–
- ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã¨ã®ä¸¡ç«‹

ãƒ“ã‚¸ãƒã‚¹å¿œç”¨:
- ã‚µãƒ—ãƒ©ã‚¤ãƒã‚§ãƒ¼ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- ã‚¯ãƒ©ã‚¦ãƒ‰ãƒã‚¤ãƒ†ã‚£ãƒ–ç’°å¢ƒå¯¾å¿œ
- IoT/OTç’°å¢ƒã§ã®æ´»ç”¨
- ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£çµ±åˆ
```

### å®Ÿè·µã¸ã®ç¬¬ä¸€æ­©

```
ğŸ¯ IoCæ´»ç”¨ã®é–‹å§‹æ‰‹é †

Phase 1: åŸºç›¤æ§‹ç¯‰ï¼ˆ1-2ãƒ¶æœˆï¼‰
â–¡ è¦ä»¶å®šç¾©ãƒ»è¨ˆç”»ç­–å®š
â–¡ ãƒ„ãƒ¼ãƒ«ãƒ»ã‚·ã‚¹ãƒ†ãƒ é¸å®š
â–¡ åŸºæœ¬çš„ãªIoCåé›†é–‹å§‹
â–¡ æ¤œçŸ¥ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ

Phase 2: é‹ç”¨é–‹å§‹ï¼ˆ2-3ãƒ¶æœˆï¼‰
â–¡ è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰é€£æº
â–¡ è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ æ§‹ç¯‰
â–¡ èª¤æ¤œçŸ¥å¯¾ç­–ã®å®Ÿè£…
â–¡ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œé€£æº

Phase 3: é«˜åº¦åŒ–ï¼ˆ3-6ãƒ¶æœˆï¼‰
â–¡ æ©Ÿæ¢°å­¦ç¿’ã®å°å…¥
â–¡ é«˜åº¦ãªåˆ†ææ©Ÿèƒ½
â–¡ å¤–éƒ¨çµ„ç¹”ã¨ã®æƒ…å ±å…±æœ‰
â–¡ ç¶™ç¶šçš„æ”¹å–„ãƒ—ãƒ­ã‚»ã‚¹
```

IoCï¼ˆIndicators of Compromiseï¼‰ã¯ã€ç¾ä»£ã®ã‚µã‚¤ãƒãƒ¼ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«ãŠã„ã¦ä¸å¯æ¬ ãªæŠ€è¡“ã§ã™ã€‚é©åˆ‡ã«å®Ÿè£…ãƒ»é‹ç”¨ã™ã‚‹ã“ã¨ã§ã€æ”»æ’ƒã®æ—©æœŸç™ºè¦‹ã€è¿…é€Ÿãªå¯¾å¿œã€ãã—ã¦çµ„ç¹”å…¨ä½“ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«å‘ä¸Šã‚’å®Ÿç¾ã§ãã¾ã™ã€‚

æŠ€è¡“çš„ãªå®Ÿè£…ã ã‘ã§ãªãã€çµ„ç¹”çš„ãªä½“åˆ¶æ•´å‚™ã‚„ç¶™ç¶šçš„ãªæ”¹å–„ãŒæˆåŠŸã®éµã¨ãªã‚Šã¾ã™ã€‚ã¾ãšã¯å°ã•ãå§‹ã‚ã¦ã€æ®µéšçš„ã«é«˜åº¦åŒ–ã—ã¦ã„ãã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚
