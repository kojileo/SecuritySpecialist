# SHA-1入門 - セキュアハッシュアルゴリズム1を理解する

## 目次
1. [SHA-1とは？](#sha-1とは)
2. [SHA-1の仕組み](#sha-1の仕組み)
3. [SHA-1の用途](#sha-1の用途)
4. [SHA-1の計算例](#sha-1の計算例)
5. [SHA-1の脆弱性](#sha-1の脆弱性)
6. [SHA-1の代替](#sha-1の代替)
7. [まとめ](#まとめ)

---

## SHA-1とは？

### 基本定義
**SHA-1（Secure Hash Algorithm 1：セキュアハッシュアルゴリズム1）**は、任意の長さのデータから160ビット（20バイト）の固定長のハッシュ値を生成する暗号学的ハッシュ関数です。

### 簡単な例え話

```
🔒 指紋の例：

SHA-1 = デジタル指紋
- 人には一人ひとり違う指紋がある
- 指紋から本人を特定できる
- 指紋は簡単には偽造できない

データ → SHA-1 → 160ビットのハッシュ値（デジタル指紋）
```

### SHA-1の特徴

1. **一方向性**: ハッシュ値から元のデータを復元できない
2. **固定長**: どんなサイズのデータでも160ビットのハッシュ値を生成
3. **決定性**: 同じデータからは必ず同じハッシュ値が生成される
4. **雪崩効果**: 入力データの小さな変更でハッシュ値が大きく変わる

### SHA-1の歴史

| 年代 | 出来事 |
|------|--------|
| **1993年** | NISTがSHA-0を発表 |
| **1995年** | SHA-1が正式に標準化（FIPS 180-1） |
| **2000年代** | 広く使用される |
| **2005年** | 理論的な脆弱性が発見 |
| **2017年** | Googleが実用的な衝突攻撃を実証 |
| **現在** | セキュリティ上推奨されない |

---

## SHA-1の仕組み

### 基本的な処理フロー

#### 1. 前処理
```
📝 前処理：

1. パディング
   - 元データの長さを512ビットの倍数にする
   - 最後に元データの長さを追加

2. ブロック分割
   - 512ビットのブロックに分割
   - 各ブロックを80個の32ビットワードに展開

例：
"Hello" → パディング → 512ビットブロック → 80個のワード
```

#### 2. ハッシュ計算
```
🔄 ハッシュ計算：

1. 初期値設定
   - H0 = 0x67452301
   - H1 = 0xEFCDAB89
   - H2 = 0x98BADCFE
   - H3 = 0x10325476
   - H4 = 0xC3D2E1F0

2. メインループ
   - 各ブロックに対して80回のラウンド処理
   - 論理演算とビットシフトを使用

3. 最終ハッシュ値
   - H0, H1, H2, H3, H4を連結
   - 160ビット（20バイト）のハッシュ値
```

### ハッシュ関数の性質

#### 1. 一方向性（One-way）
```
🔒 一方向性：

入力: "Hello World"
SHA-1出力: a591a6d40bf420404a011733cfb7b190d62c65bf0

逆算不可能:
ハッシュ値から元の文字列を求めることは実質的に不可能
```

#### 2. 衝突耐性（Collision Resistance）
```
⚠️ 衝突耐性（現在は脆弱）：

理想: 異なる入力から同じハッシュ値が生成されることはない
現実: SHA-1では衝突攻撃が可能（後述）
```

#### 3. 雪崩効果（Avalanche Effect）
```
❄️ 雪崩効果：

入力1: "Hello World"
SHA-1: a591a6d40bf420404a011733cfb7b190d62c65bf0

入力2: "Hello World!"  (1文字追加)
SHA-1: 0a0a9f2a6772942557ab5355d76af442f8f65e01

→ 1文字の変更でハッシュ値が大きく変化
```

---

## SHA-1の用途

### 1. データ整合性検証

#### ファイルの改ざん検出
```
📁 ファイル整合性：

用途：
- ソフトウェア配布時の改ざん検出
- バックアップデータの整合性確認
- ファイル転送時のエラー検出

例：
ファイル: program.exe
SHA-1: 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12

配布時にSHA-1値を公開
ユーザーがダウンロード後にSHA-1値を計算
値が一致すれば改ざんされていない
```

#### データベースの整合性
```
🗄️ データベース整合性：

用途：
- データベースの整合性チェック
- レプリケーション時の同期確認
- バックアップの検証

例：
テーブル: users
レコード数: 1000
SHA-1: a1b2c3d4e5f6...

定期的にSHA-1値を計算
値が変わればデータが変更された
```

### 2. デジタル署名

#### 証明書の検証
```
🔐 デジタル証明書：

用途：
- SSL/TLS証明書の署名
- コード署名
- 電子文書の署名

注意：
現在はSHA-1による証明書は推奨されない
SHA-256以上を使用する必要がある
```

### 3. パスワードハッシュ

#### パスワード保存
```
🔑 パスワードハッシュ：

用途：
- データベースでのパスワード保存
- 認証システムでのパスワード検証

注意：
SHA-1単体でのパスワードハッシュは脆弱
ソルト（Salt）の追加が必要
より安全なPBKDF2やbcryptを推奨
```

---

## SHA-1の計算例

### 1. コマンドラインでの計算

#### Linux/macOS
```bash
# 文字列のSHA-1計算
echo -n "Hello World" | sha1sum
# 出力: 0a0a9f2a6772942557ab5355d76af442f8f65e01

# ファイルのSHA-1計算
sha1sum filename.txt
# 出力: 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12  filename.txt

# 複数ファイルの計算
sha1sum *.txt
```

#### Windows
```cmd
# PowerShellでの計算
Get-FileHash -Path "filename.txt" -Algorithm SHA1

# certutilでの計算
certutil -hashfile filename.txt SHA1
```

### 2. プログラミングでの計算

#### Python
```python
import hashlib

# 文字列のSHA-1計算
text = "Hello World"
sha1_hash = hashlib.sha1(text.encode()).hexdigest()
print(sha1_hash)  # 0a0a9f2a6772942557ab5355d76af442f8f65e01

# ファイルのSHA-1計算
def calculate_file_sha1(filename):
    sha1_hash = hashlib.sha1()
    with open(filename, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha1_hash.update(chunk)
    return sha1_hash.hexdigest()

file_hash = calculate_file_sha1("example.txt")
print(file_hash)
```

#### Java
```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class SHA1Example {
    public static String calculateSHA1(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            byte[] hash = md.digest(input.getBytes());
            
            StringBuilder sb = new StringBuilder();
            for (byte b : hash) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
    
    public static void main(String[] args) {
        String input = "Hello World";
        String sha1 = calculateSHA1(input);
        System.out.println(sha1);  // 0a0a9f2a6772942557ab5355d76af442f8f65e01
    }
}
```

#### JavaScript
```javascript
// Node.jsでの計算
const crypto = require('crypto');

// 文字列のSHA-1計算
const text = 'Hello World';
const hash = crypto.createHash('sha1').update(text).digest('hex');
console.log(hash);  // 0a0a9f2a6772942557ab5355d76af442f8f65e01

// ファイルのSHA-1計算
const fs = require('fs');
const fileBuffer = fs.readFileSync('example.txt');
const fileHash = crypto.createHash('sha1').update(fileBuffer).digest('hex');
console.log(fileHash);
```

### 3. 実際の計算例

#### 様々な入力でのSHA-1値
```
📊 計算例：

入力: ""
SHA-1: da39a3ee5e6b4b0d3255bfef95601890afd80709

入力: "a"
SHA-1: 86f7e437faa5a7fce15d1ddcb9eaeaea377667b8

入力: "abc"
SHA-1: a9993e364706816aba3e25717850c26c9cd0d89d

入力: "Hello World"
SHA-1: 0a0a9f2a6772942557ab5355d76af442f8f65e01

入力: "The quick brown fox jumps over the lazy dog"
SHA-1: 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12
```

---

## SHA-1の脆弱性

### 理論的な脆弱性

#### 1. 衝突攻撃
```
⚠️ 衝突攻撃：

定義：
異なる2つの入力から同じSHA-1ハッシュ値を生成する攻撃

理論値：
- 誕生日攻撃により2^80の計算量で衝突可能
- 実際の実装では2^63程度で衝突可能

影響：
- デジタル署名の偽造
- 証明書の偽造
- ファイルの改ざん検出の回避
```

#### 2. 実用的な攻撃（2017年）
```
🚨 Googleの実証（2017年）：

攻撃名: SHAttered
攻撃内容：
- 2つの異なるPDFファイルが同じSHA-1ハッシュ値を持つ
- 約2^63の計算量で衝突を実現
- 実用的な時間（数ヶ月）で攻撃が可能

証明されたファイル：
- shattered-1.pdf
- shattered-2.pdf
両方とも同じSHA-1: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a
```

### セキュリティ上の問題

#### 1. 証明書の偽造
```
🔐 証明書偽造の脅威：

攻撃シナリオ：
1. 攻撃者が有効な証明書のSHA-1ハッシュ値を計算
2. 同じハッシュ値を持つ悪意のある証明書を生成
3. ブラウザが有効な証明書と誤認
4. 中間者攻撃が可能になる

対策：
- SHA-256以上のハッシュ関数を使用
- SHA-1証明書の発行を停止
```

#### 2. デジタル署名の偽造
```
✍️ 署名偽造の脅威：

攻撃シナリオ：
1. 攻撃者が正当な文書のSHA-1ハッシュ値を取得
2. 同じハッシュ値を持つ偽文書を作成
3. 正当な文書の署名を偽文書に適用
4. 偽文書が正当であると誤認される

対策：
- SHA-256以上のハッシュ関数を使用
- 署名アルゴリズムの更新
```

### 現在の状況

#### 1. ブラウザでの対応
```
🌐 ブラウザ対応：

Chrome: SHA-1証明書を警告表示（2017年〜）
Firefox: SHA-1証明書を信頼しない（2017年〜）
Safari: SHA-1証明書を警告表示（2017年〜）
Edge: SHA-1証明書を警告表示（2017年〜）

現在：主要ブラウザはSHA-1証明書を拒否
```

#### 2. 証明書機関の対応
```
🏢 証明書機関の対応：

Symantec: SHA-1証明書の発行停止（2016年）
DigiCert: SHA-1証明書の発行停止（2016年）
Let's Encrypt: 最初からSHA-256のみ
GlobalSign: SHA-1証明書の発行停止（2016年）

現在：主要なCAはSHA-1証明書を発行しない
```

---

## SHA-1の代替

### 推奨される代替アルゴリズム

#### 1. SHA-256
```
🔒 SHA-256：

特徴：
- 256ビット（32バイト）のハッシュ値
- SHA-2ファミリーの一部
- 現在最も広く使用されている
- 衝突攻撃に対して安全

用途：
- SSL/TLS証明書
- デジタル署名
- データ整合性検証
- 暗号通貨（Bitcoin等）
```

#### 2. SHA-384/SHA-512
```
🔒 SHA-384/SHA-512：

特徴：
- SHA-384: 384ビット（48バイト）
- SHA-512: 512ビット（64バイト）
- より高いセキュリティレベル
- 64ビットシステムで高速

用途：
- 高セキュリティが要求されるシステム
- 長期保存が必要なデータ
- 政府・軍事用途
```

#### 3. SHA-3（Keccak）
```
🔒 SHA-3：

特徴：
- 2015年にNISTが標準化
- SHA-1/SHA-2とは異なる設計
- 将来の量子コンピュータ攻撃に対応
- 柔軟な出力長

用途：
- 次世代セキュリティシステム
- 量子耐性が必要なシステム
- 新しい暗号システム
```

### 移行のガイドライン

#### 1. システム移行
```
🔄 移行手順：

1. 現状調査
   - SHA-1を使用している箇所の特定
   - 影響範囲の評価
   - 移行計画の策定

2. 段階的移行
   - 新規システムではSHA-256以上を使用
   - 既存システムの優先度付け
   - 重要なシステムから順次移行

3. 検証・テスト
   - 移行後の動作確認
   - パフォーマンステスト
   - セキュリティテスト
```

#### 2. 開発時の考慮事項
```
💻 開発時の注意：

推奨：
- 新規開発ではSHA-256以上を使用
- ハッシュ関数の選択を設定可能にする
- 将来の移行を考慮した設計

避けるべき：
- SHA-1の新規採用
- ハードコーディングされたSHA-1
- セキュリティクリティカルな用途でのSHA-1
```

### パフォーマンス比較

#### 計算速度の比較
```
⚡ パフォーマンス比較（参考値）：

SHA-1:     100%
SHA-256:    85%
SHA-384:    75%
SHA-512:    80%
SHA-3:      60%

注意：
- 実装やハードウェアにより異なる
- セキュリティを優先すべき
- パフォーマンスは最適化可能
```

---

## まとめ

### SHA-1の重要なポイント

1. **歴史的意義**: 広く使用された暗号学的ハッシュ関数
2. **基本機能**: 160ビットの固定長ハッシュ値生成
3. **脆弱性**: 衝突攻撃が実証され、セキュリティ上問題
4. **非推奨**: 現在は新規採用すべきでない

### SHA-1の現在の位置づけ

#### 使用すべきでない場面
```
❌ 避けるべき用途：

- SSL/TLS証明書
- デジタル署名
- セキュリティクリティカルなシステム
- 新規開発プロジェクト
- 長期保存が必要なデータ
```

#### 限定的に使用可能な場面
```
⚠️ 限定的な用途：

- レガシーシステムの互換性維持
- 非セキュリティ用途（チェックサム等）
- 一時的な用途
- 段階的移行中のシステム

注意：可能な限り早期の移行を推奨
```

### 移行の重要性

#### 1. セキュリティリスク
- **証明書偽造**: 中間者攻撃の可能性
- **署名偽造**: 文書の改ざん検出回避
- **システム侵害**: セキュリティホールの悪用

#### 2. ビジネスリスク
- **ブラウザ警告**: ユーザー体験の悪化
- **コンプライアンス**: セキュリティ要件の不適合
- **信頼性**: システムの信頼性低下

#### 3. 移行のベネフィット
- **セキュリティ向上**: 最新の暗号技術の活用
- **将来性**: 長期的なセキュリティ確保
- **互換性**: 最新ブラウザとの互換性確保

### 推奨事項

#### 1. 即座に実行すべきこと
- **新規システム**: SHA-256以上の採用
- **既存システム**: 移行計画の策定
- **監査**: SHA-1使用箇所の特定

#### 2. 段階的に実行すべきこと
- **重要システム**: 優先的に移行
- **レガシーシステム**: 段階的移行
- **テスト**: 移行後の十分な検証

#### 3. 継続的に実行すべきこと
- **監視**: 新しい脆弱性の情報収集
- **更新**: 暗号技術の最新動向の把握
- **教育**: 開発チームへの教育・啓蒙

SHA-1は暗号学の歴史において重要な役割を果たしましたが、現在はセキュリティ上の理由から使用を避けるべきアルゴリズムです。適切な代替アルゴリズムへの移行により、セキュリティを確保し、将来にわたって安全なシステムを構築することが重要です。
